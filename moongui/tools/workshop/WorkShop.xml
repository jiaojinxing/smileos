<?xml version="1.0" encoding="gb2312"?>
<WorkShop>
<CommonFiles>
<ASM>
<file name="system.h">
<![CDATA[

#ifndef __SYSTEM_H
#define __SYSTEM_H

#ifdef __cplusplus
extern "C" {
#endif

int clrscr();
int exit(int exit_code);
int get_text_size();
int load_data(char *buf,int size);
int get_time();
int get_name(int i,char *buf,int max);
int get_self_num();
int get_cookie_size(int i);
int set_cookie_size(int i,int size);
int get_cookie_offset(int i);
int set_cookie_offset(int i,int off);
int read_cookie(int i,void *buf,int rsize);
int write_cookie(int i,void *buf,int wsize);
int putchar(int ch);

#ifdef __cplusplus
} //extern "C"
#endif
#endif

]]>
</file>
<file name="_bootloader.asm">
<![CDATA[
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; _bootloader.asm
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
if @Version gt 510
	.model FLAT
endif
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
_DATA SEGMENT
__reserved		DD 		20 dup(?)               ;80 bytes reserved
__fltused       dd      9875h                   ; Floating point used flag
__infinity      db      6 dup(0), 0f0h, 07fh    ; Floating point infinity
__nan           db      6 dup(0ffh), 0f8h, 0ffh ; Floating point NaN
_DATA ENDS
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;;the first instruction in first _TEXT segment 
;;must be call __init
_TEXT SEGMENT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_boot_loader proc
	call __init
endless:
	int 0
	jmp endless
	ret 
_boot_loader endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;int exit(int exit_code)
_exit proc
	int 0
	ret
_exit endp

;;int putchar(int ch)
_putchar proc
	int 1
	ret
_putchar endp

;;int set_pixel(int x,int y,COLORREG c)
_set_pixel proc
	int 2
	ret
_set_pixel endp

;;int set_bk_color(COLORREF c)
_set_bk_color proc
	int 3
	ret
_set_bk_color endp

;;int arc(int nLeftRect,int nTopRect,int nRightRect,int nBottomRect,
;;				int nXRadial1,int nYRadial1,int nXRadial2,int nYRadial2)
_arc proc
	int 4
	ret
_arc endp

;;int line(int l,int t,int r,int b)
_line proc
	int 6
	ret
_line endp

;;int get_rect(int i,int *l,int *t,int *r,int *b)
_get_rect proc
	mov ebp,esp
	int 7
	pop eax
	mov ebx, dword ptr [ebp + 20]
	mov dword ptr [ebx],eax
	pop eax
	mov ebx, dword ptr [ebp + 16]
	mov dword ptr [ebx],eax	
	pop eax
	mov ebx, dword ptr [ebp + 12]
	mov dword ptr [ebx],eax	
	pop eax
	mov ebx, dword ptr [ebp + 8]
	mov dword ptr [ebx],eax		
	ret
_get_rect endp

;;int set_pen(int style,int width,COLORREF color)
_set_pen proc
	int 8
	ret
_set_pen endp

;;int set_rect(int i,int l,int t,int r,int b)
_set_rect proc
	int 9
	ret
_set_rect endp

;;int set_brush(int style,COLORREF color,int hatch)
_set_brush proc
	int 10
	ret
_set_brush endp

;;int fill_rect(int l,int t,int w,int h)
_fill_rect proc
	int 12
	ret
_fill_rect endp

;;int draw_text(char *str,int size,RECT *rect,DWORD format)
_draw_text proc
	int 13
	ret
_draw_text endp

;;int set_stock_font(int stock_font)
_set_stock_font proc
	int 14
	ret
_set_stock_font endp

;;int ellipse(int l,int t,int w,int h)
_ellipse proc
	int 15
	ret
_ellipse endp

;;int get_name(int i,char *buf,int max)
_get_name proc
	int 16
	ret
_get_name endp

;;int get_self_num()
_get_self_num proc
	int 17
	pop eax  ;;the return number
	ret
_get_self_num endp

;;int get_cookie_size(int i)
_get_cookie_size proc
	int 18
	pop eax
	ret
_get_cookie_size endp

;;int set_cookie_size(int i,int size)
_set_cookie_size proc
	int 19
	ret
_set_cookie_size endp

;;int get_cookie_offset(int i)
_get_cookie_offset proc
	int 20
	pop eax
	ret
_get_cookie_offset endp

;;int set_cookie_offset(int i,int off)
_set_cookie_offset proc
	int 21
	ret
_set_cookie_offset endp

;;int read_cookie(int i,void *buf,int rsize)
_read_cookie proc
	int 22
	pop eax
	ret
_read_cookie endp

;;int write_cookie(int i,void *buf,int wsize)
_write_cookie proc
	int 23
	pop eax
	ret
_write_cookie endp

;;int set_text_color(COLORREF color)
_set_text_color proc
	int 24
	ret
_set_text_color endp

;;int set_bk_mode(int mode)
_set_bk_mode proc
	int 25
	ret
_set_bk_mode endp

;;int set_font(LOGFONT *lf)
_set_font proc
	int 26
	ret
_set_font endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_TEXT ENDS
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
_DATA SEGMENT
fzero           DQ   0	            ;Floating point zero
_DATA ENDS
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
_TEXT SEGMENT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
__purecall proc
	ret								;;nothing
__purecall endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
__allmul proc 
	mov         eax,dword ptr [esp+8]
	mov         ecx,dword ptr [esp+10h]
	or          ecx,eax
	mov         ecx,dword ptr [esp+0Ch]
	jne         hard
	mov         eax,dword ptr [esp+4]
	mul         eax,ecx
	ret         10h
hard:
	push        ebx
	mul         eax,ecx
	mov         ebx,eax
	mov         eax,dword ptr [esp+8]
	mul         eax,dword ptr [esp+14h]
	add         ebx,eax
	mov         eax,dword ptr [esp+8]
	mul         eax,ecx
	add         edx,ebx
	pop         ebx
	ret         10h
__allmul endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
__ftol proc
	push        ebp
	mov         ebp,esp
	add         esp,0F4h
	wait
	fnstcw      word ptr [ebp-2]
	wait
	mov         ax,word ptr [ebp-2]
	or          ah,0Ch
	mov         word ptr [ebp-4],ax
	fldcw       word ptr [ebp-4]
	fistp       qword ptr [ebp-0Ch]
	fldcw       word ptr [ebp-2]
	mov         eax,dword ptr [ebp-0Ch]
	mov         edx,dword ptr [ebp-8]
	leave
	ret			0
__ftol endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
__chkstk proc
	push        ecx
	cmp         eax,1000h
	lea         ecx,[esp+8]
	jb          lastpage 
probepages:
	sub         ecx,1000h
	sub         eax,1000h
	test        dword ptr [ecx],eax
	cmp         eax,1000h
	jae         probepages
lastpage:
	sub         ecx,eax
	mov         eax,esp
	test        dword ptr [ecx],eax
	mov         esp,ecx
	mov         ecx,dword ptr [eax]
	mov         eax,dword ptr [eax+4]
	push        eax
	ret
_chkstk endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_atexit proc
	ret
_atexit endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
__CIasin proc
    fld     st(0)                   ; Load x
    fld     st(0)                   ; Load x
    fmul                            ; Multiply (x squared)
    fld1                            ; Load 1
    fsubr                           ; 1 - (x squared)
    fsqrt                           ; Square root of (1 - x squared)
    fpatan                          ; This gives the arc sine !
    ret
__CIasin endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
__CIacos proc
    fld     st(0)                   ; Load x
    fld     st(0)                   ; Load x
    fmul                            ; Multiply (x squared)
    fld1                            ; Load 1
    fsubr                           ; 1 - (x squared)
    fsqrt                           ; Square root of (1 - x squared)
    fxch                            ; Exchange st, st(1)
    fpatan                          ; This gives the arc cosine !
    ret
__CIacos endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_pow proc    
    push    ebp
    mov     ebp,esp
    sub     esp,12                  ; Allocate temporary space
    push    edi                     ; Save register edi
    push    eax                     ; Save register eax
    mov     dword ptr [ebp-12],0    ; Set negation flag to zero
    fld     qword ptr [ebp+16]      ; Load real from stack
    fld     qword ptr [ebp+8]       ; Load real from stack
    mov     edi,offset flat:fzero   ; Point to real zero
    fcom    qword ptr [edi]         ; Compare x with zero
    fstsw   ax                      ; Get the FPU status word
    mov     al,ah                   ; Move condition flags to AL
    lahf                            ; Load Flags into AH
    and     al,    69               ; Isolate  C0, C2 and C3
    and     ah,    186              ; Turn off CF, PF and ZF
    or      ah,al                   ; Set new  CF, PF and ZF
    sahf                            ; Store AH into Flags
    jb      __fpow1                 ; Re-direct if x < 0
    ja      __fpow3                 ; Re-direct if x > 0
    fxch                            ; Swap st, st(1)
    fcom    qword ptr [edi]         ; Compare y with zero
    fxch                            ; Restore x as top of stack
    fstsw   ax                      ; Get the FPU status word
    mov     al,ah                   ; Move condition flags to AL
    lahf                            ; Load Flags into AH
    and     al,69                   ; Isolate  C0, C2 and C3
    and     ah,186                  ; Turn off CF, PF and ZF
    or      ah,al                   ; Set new  CF, PF and ZF
    sahf                            ; Store AH into Flags
    ja      __fpow3                 ; Re-direct if y > 0
    fstp    st(1)                   ; Set new stack top and pop
    mov     eax,1                   ; Set domain error (EDOM)
    jmp     __fpow6                 ; End of case
__fpow1:        
	fxch                            ; Put y on top of stack
    fld    st(0)                    ; Duplicate y as st(1)
    frndint                         ; Round to integer
    fxch                            ; Put y on top of stack
    fcomp                           ; y = int(y) ?
    fstsw   ax                      ; Get the FPU status word
    mov     al,ah                   ; Move condition flags to AL
    lahf                            ; Load Flags into AH
    and     al,    69               ; Isolate  C0, C2 and C3
    and     ah,    186              ; Turn off CF, PF and ZF
    or      ah,al                   ; Set new  CF, PF and ZF
    sahf                            ; Store AH into Flags
    je      __fpow2                 ; Proceed if y = int(y)
    fstp    st(1)                   ; Set new stack top and pop
    fldz                            ; Set result to zero
    fstp    st(1)                   ; Set new stack top and pop
    mov     eax,1                   ; Set domain error (EDOM)
    jmp     __fpow6                 ; End of case
__fpow2:        
	fist    dword ptr [ebp-12]      ; Store y as integer
    and     dword ptr [ebp-12],1    ; Set bit if y is odd
    fxch                            ; Put x on top of stack
    fabs                            ; x = |x|
__fpow3:        
	fldln2                          ; Load log base e of 2
    fxch    st(1)                   ; Exchange st, st(1)
    fyl2x                           ; Compute the natural log(x)
    fmul                            ; Compute y * ln(x)
    fldl2e                          ; Load log base 2(e)
    fmulp   st(1),st(0)             ; Multiply x * log base 2(e)
    fst     st(1)                   ; Push result
    frndint                         ; Round to integer
    fsub    st(1),st(0)             ; Subtract
    fxch                            ; Exchange st, st(1)
    f2xm1                           ; Compute 2 to the (x - 1)
    fld1                            ; Load real number 1
    fadd                            ; 2 to the x
    fscale                          ; Scale by power of 2
    fstp    st(1)                   ; Set new stack top and pop
    test    dword ptr [ebp-12],1    ; Negation required ?
    je      __fpow4                 ; No, re-direct
    fchs                            ; Negate the result
__fpow4:       
	fstp    qword ptr [ebp-8]       ; Save (double)pow(x, y)
    fld     qword ptr [ebp-8]       ; Load (double)pow(x, y)
    fxam                            ; Examine st
    fstsw   ax                      ; Get the FPU status word
    cmp     ah,5                    ; Infinity ?
    jne     __fpow6                 ; No, end of case
    mov     eax,2                   ; Set range error (ERANGE)
__fpow6:        
	pop     eax                     ; Restore register eax
    pop     edi                     ; Restore register edi
    mov     esp,ebp                 ; Deallocate temporary space
    pop     ebp
    ret
_pow            endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
__CIpow proc
    sub     esp,16                  ; Allocate stack space for args
    fstp    qword ptr [esp+8]       ; Copy y onto stack
    fstp    qword ptr [esp]         ; Copy x onto stack
    call    _pow                    ; Call pow
    add     esp,16                  ; Remove args from stack
    ret
__CIpow endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_ceil proc 
    push    ebp
    mov     ebp,esp
    sub     esp,4                   ; Allocate temporary space
    fld     qword ptr [ebp+8]       ; Load real from stack
    fstcw   [ebp-2]                 ; Save control word
    fclex                           ; Clear exceptions
    mov     word ptr [ebp-4],0b63h  ; Rounding control word
    fldcw   [ebp-4]                 ; Set new rounding control
    frndint                         ; Round to integer
    fclex                           ; Clear exceptions
    fldcw   [ebp-2]                 ; Restore control word
    mov     esp,ebp                 ; Deallocate temporary space
    pop     ebp
    ret
_ceil endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_log10 proc
    push    ebp
    mov     ebp,esp
    fld     qword ptr [ebp+8]       ; Load real from stack
    fldlg2                          ; Load log base 10 of 2
    fxch    st(1)                   ; Exchange st, st(1)
    fyl2x                           ; Compute the log base 10(x)
    pop     ebp
    ret
_log10 endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_modf  proc
    push    ebp
    mov     ebp,esp
    push    edi                     ; Save register edi
    fld     qword ptr [ebp+8]       ; Load real from stack
    mov     edi,dword ptr [ebp+16]  ; Put integer address in edi
    fld     st(0)                   ; Duplicate st
    frndint                         ; Round to integer
    fcom    st(1)                   ; Compare with orignal value
    fstsw   ax                      ; Get the FPU status word
    test    byte ptr [ebp+15],080h  ; Test if number is negative
    je      __fmodf1                ; Re-direct if positive
    sahf                            ; Store AH to flags
    jae     __fmodf2                ; Re-direct if greater or equal
    fld1                            ; Load the constant 1
    fadd                            ; Increment integer part
    jmp     __fmodf2                ; End of case
__fmodf1:
    sahf                            ; Store AH to flags
    jbe     __fmodf2                ; Re-direct if less or equal
    fld1                            ; Load constant 1
    fsub                            ; Decrement integer part
__fmodf2:       
    fst     qword ptr [edi]         ; Store integer part
    fsub                            ; Subtract to get fraction
    pop     edi                     ; Restore register edi
    mov     esp,ebp                 ; Restore stack pointer
    pop     ebp
    ret
_modf endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
__CIfmod proc
    fxch    st(1)                   ; Swap arguments
__CIfmod1:   
    fprem                           ; Get the partial remainder
    fstsw   ax                      ; Get coprocessor status
    test    ax,0400h                ; Complete remainder ?
    jnz     __CIfmod1               ; No, go get next remainder
    fstp    st(1)                   ; Set new top of stack
    ret
__CIfmod endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_ceil proc
    push    ebp
    mov     ebp,esp
    sub     esp,4                   ; Allocate temporary space
    fld     qword ptr [ebp+8]       ; Load real from stack
    fstcw   [ebp-2]                 ; Save control word
    fclex                           ; Clear exceptions
    mov     word ptr [ebp-4],0b63h  ; Rounding control word
    fldcw   [ebp-4]                 ; Set new rounding control
    frndint                         ; Round to integer
    fclex                           ; Clear exceptions
    fldcw   [ebp-2]                 ; Restore control word
    mov     esp,ebp                 ; Deallocate temporary space
    pop     ebp
    ret
_ceil endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_floor proc
    push    ebp
    mov     ebp,esp
    sub     esp,4                   ; Allocate temporary space
    fld     qword ptr [ebp+8]       ; Load real from stack
    fstcw   [ebp-2]                 ; Save control word
    fclex                           ; Clear exceptions
    mov     word ptr [ebp-4],0763h  ; Rounding control word
    fldcw   [ebp-4]                 ; Set new rounding control
    frndint                         ; Round to integer
    fclex                           ; Clear exceptions
    fldcw   [ebp-2]                 ; Restore control word
    mov     esp,ebp
    pop     ebp
    ret
_floor endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_tanh proc
    push    ebp
    mov     ebp,esp
    fld     qword ptr [ebp+8]       ; Load real from stack
    fld     st(0)                   ; Duplicate stack top
    fadd                            ; Compute 2 * x
    fldl2e                          ; Load log base 2(e)
    fmulp   st(1),st(0)             ; Multiply x * log base 2(e)
    fst     st(1)                   ; Push result
    frndint                         ; Round to integer
    fsub    st(1),st(0)             ; Subtract
    fxch                            ; Exchange st, st(1)
    f2xm1                           ; Compute 2 to the (x - 1)
    fld1                            ; Load real number 1
    fadd                            ; 2 to the x
    fscale                          ; Scale by power of 2
    fstp    st(1)                   ; Set new stack top and pop
    fld1                            ; Load constant 1
    fadd                            ; Compute exp(2*x)+1
    fld1                            ; Load the constant 1
    fld1                            ; Load the constant 1
    fadd                            ; Set divisor to 2
    fdivr                           ; Compute 2/(exp(2*x)+1)
    fld1                            ; Load constant 1
    fsubr                           ; Compute the hyperbolic tangent
    pop     ebp                     ; Restore register bp
    ret
_tanh endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
__CItanh proc
    sub     esp,8                   ; Allocate stack space for x
    fstp    qword ptr [esp]         ; Copy x onto stack
    call    _tanh                   ; Call tanh
    add     esp,8                   ; Remove x from stack
    ret
__CItanh endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_sinh proc
    push    ebp
    mov     ebp,esp
    sub     esp,8                   ; Allocate temporary space
    fld     qword ptr [ebp+8]       ; Load real from stack
    fchs                            ; Set x = -x
    fldl2e                          ; Load log base 2(e)
    fmulp   st(1),st(0)             ; Multiply x * log base 2(e)
    fst     st(1)                   ; Push result
    frndint                         ; Round to integer
    fsub    st(1),st(0)             ; Subtract
    fxch                            ; Exchange st, st(1)
    f2xm1                           ; Compute 2 to the (x - 1)
    fld1                            ; Load real number 1
    fadd                            ; 2 to the x
    fscale                          ; Scale by power of 2
    fstp    st(1)                   ; Set new stack top and pop
    fstp    qword ptr [ebp-8]       ; Save exp(-x)
    fld     qword ptr [ebp+8]       ; Load real from stack
    fldl2e                          ; Load log base 2(e)
    fmulp   st(1),st(0)             ; Multiply x * log base 2(e)
    fst     st(1)                   ; Push result
    frndint                         ; Round to integer
    fsub    st(1),st(0)             ; Subtract
    fxch                            ; Exchange st, st(1)
    f2xm1                           ; Compute 2 to the (x - 1)
    fld1                            ; Load real number 1
    fadd                            ; 2 to the x
    fscale                          ; Compute exp(-x)
    fstp    st(1)                   ; Set new stack top and pop
    fld     qword ptr [ebp-8]       ; Get exp(x)
    fsub                            ; Compute exp(x) - exp(-x)
    fld1                            ; Load the constant 1
    fld1                            ; Load the constant 1
    fadd                            ; Set divisor to 2
    fdiv                            ; Compute the hyperbolic sine
    mov     esp,ebp                 ; Deallocate temporary space
    pop     ebp
    ret
_sinh endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
__CIsinh proc
    sub     esp,8                   ; Allocate stack space for x
    fstp    qword ptr [esp]         ; Copy x onto stack
    call    _sinh                   ; Call sinh
    add     esp,8                   ; Remove x from stack
    ret
__CIsinh endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_atan2 proc
    push    ebp
    mov     ebp,esp
    fld     qword ptr [ebp+8]       ; Load real from stack
    fld     qword ptr [ebp+16]      ; Load real from stack
    fpatan                          ; Take the arctangent
    mov     esp,ebp
    pop     ebp
    ret
_atan2 endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_cosh proc
    push    ebp
    mov     ebp,esp
    sub     esp,8                   ; Allocate temporary space
    fld     qword ptr [ebp+8]       ; Load real from stack
    fchs                            ; Set x = -x
    fldl2e                          ; Load log base 2(e)
    fmulp   st(1),st(0)             ; Multiply x * log base 2(e)
    fst     st(1)                   ; Push result
    frndint                         ; Round to integer
    fsub    st(1),st(0)             ; Subtract
    fxch                            ; Exchange st, st(1)
    f2xm1                           ; Compute 2 to the (x - 1)
    fld1                            ; Load real number 1
    fadd                            ; 2 to the x
    fscale                          ; Scale by power of 2
    fstp    st(1)                   ; Set new stack top and pop
    fstp    qword ptr [ebp-8]       ; Save exp(-x)
    fld     qword ptr [ebp+8]       ; Load real from stack
    fldl2e                          ; Load log base 2(e)
    fmulp   st(1),st(0)             ; Multiply x * log base 2(e)
    fst     st(1)                   ; Push result
    frndint                         ; Round to integer
    fsub    st(1),st(0)             ; Subtract
    fxch                            ; Exchange st, st(1)
    f2xm1                           ; Compute 2 to the (x - 1)
    fld1                            ; Load real number 1
    fadd                            ; 2 to the x
    fscale                          ; Compute exp(-x)
    fstp    st(1)                   ; Set new stack top and pop
    fld     qword ptr [ebp-8]       ; Get exp(x)
    fadd                            ; Compute exp(x) + exp(-x)
    fld1                            ; Load the constant 1
    fld1                            ; Load the constant 1
    fadd                            ; Set divisor to 2
    fdiv                            ; Compute the hyperbolic cosine
    mov     esp,ebp                 ; Deallocate temporary space
    pop     ebp
    ret
_cosh endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
__CIcosh proc
    sub     esp,8                   ; Allocate stack space for x
    fstp    qword ptr [esp]         ; Copy x onto stack
    call    _cosh                   ; Call cosh
    add     esp,8                   ; Remove x from stack
    ret
__CIcosh endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_frexp proc
    push    ebp
    mov     ebp,esp
    push    edi                     ; Save register edi
    fld     qword ptr [ebp+8]       ; Load real from stack
    mov     edi,dword ptr [ebp+16]  ; Put exponent address in edi
    ftst                            ; Test st for zero
    fstsw   ax                      ; Put test result in ax
    sahf                            ; Set flags based on test
    jnz     __frexp1                ; Re-direct if not zero
    fld     st(0)                   ; Set exponent to zero
    jmp     __frexp2                ; End of case
__frexp1:  
    fxtract                         ; Get exponent and significand
    fld1                            ; Load constant 1
    fld1                            ; Load constant 1
    fadd                            ; Constant 2
    fdiv                            ; Significand / 2
    fxch                            ; Swap st, st(1)
    fld1                            ; Load constant 1
    fadd                            ; Increment exponent
    fistp   dword ptr [edi]         ; Store result exponent and pop
__frexp2:
    pop     edi                     ; Restore register edi
    mov     esp,ebp
    pop     ebp
    ret
_frexp          endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_ldexp proc 
    push    ebp
    mov     ebp,esp
    sub     esp,8                   ; Allocate temporary space
    fild    dword ptr [ebp+16]      ; Load n as integer
    fld     qword ptr [ebp+8]       ; Load real from stack
    fscale                          ; Compute 2 to the n
    fstp    st(1)                   ; Set new top of stack
    fst     qword ptr [ebp-8]       ; Store result
    mov     esp,ebp                 ; Deallocate temporary space
    pop     ebp
    ret
_ldexp endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
_TEXT ENDS
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
]]>
</file>
</ASM>
<RunTime>
<file name="stdafx.h">
<![CDATA[
//nothing
]]>
</file>
<file name="stdio.h">
<![CDATA[
#ifndef __STDIO_2007_12_11_14_5_49_H
#define __STDIO_2007_12_11_14_5_49_H

#include "stdarg.h"
#include "types.h"

#ifdef __cplusplus
extern "C" {
#endif

int putchar(int ch);
int puts(const char *str);
int sprintf(char *buf, const char *fmt, ...);
int printf(const char *fmt, ...);
int vsprintf(char *buf, const char *fmt, va_list args);

#ifdef __cplusplus
} //extern "C"
#endif

#endif
]]>
</file>
<file name="stdio.c">
<![CDATA[
#include "stdio.h"
#include "types.h"
#include "stdarg.h"
#include "string.h"
#include "math.h"

#define ZEROPAD	1		// Pad with zero
#define SIGN	2		// Unsigned/signed long
#define PLUS	4		// Show plus
#define SPACE	8		// Space if plus
#define LEFT	16		// Left justified
#define SPECIAL	32		// 0x
#define LARGE	64		// Use 'ABCDEF' instead of 'abcdef'

#define is_digit(c) ((c) >= '0' && (c) <= '9')

static char *digits = "0123456789abcdefghijklmnopqrstuvwxyz";
static char *upper_digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

char *ecvtbuf(double arg, int ndigits, int *decpt, int *sign, char *buf);
char *fcvtbuf(double arg, int ndigits, int *decpt, int *sign, char *buf);

static size_t strnlen(const char *s, size_t count)
{
  const char *sc;
  for (sc = s; *sc != '\0' && count--; ++sc);
  return sc - s;
}

static int skip_atoi(const char **s)
{
  int i = 0;
  while (is_digit(**s)) i = i*10 + *((*s)++) - '0';
  return i;
}

static char *number(char *str, long num, int base, int size, int precision, int type)
{
  char c, sign, tmp[66];
  char *dig = digits;
  int i;

  if (type & LARGE)  dig = upper_digits;
  if (type & LEFT) type &= ~ZEROPAD;
  if (base < 2 || base > 36) return 0;
  
  c = (type & ZEROPAD) ? '0' : ' ';
  sign = 0;
  if (type & SIGN)
  {
    if (num < 0)
    {
      sign = '-';
      num = -num;
      size--;
    }
    else if (type & PLUS)
    {
      sign = '+';
      size--;
    }
    else if (type & SPACE)
    {
      sign = ' ';
      size--;
    }
  }

  if (type & SPECIAL)
  {
    if (base == 16)
      size -= 2;
    else if (base == 8)
      size--;
  }

  i = 0;

  if (num == 0)
    tmp[i++] = '0';
  else
  {
    while (num != 0)
    {
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
      num = ((unsigned long) num) / (unsigned) base;
    }
  }

  if (i > precision) precision = i;
  size -= precision;
  if (!(type & (ZEROPAD | LEFT))) while (size-- > 0) *str++ = ' ';
  if (sign) *str++ = sign;
  
  if (type & SPECIAL)
  {
    if (base == 8)
      *str++ = '0';
    else if (base == 16)
    {
      *str++ = '0';
      *str++ = digits[33];
    }
  }

  if (!(type & LEFT)) while (size-- > 0) *str++ = c;
  while (i < precision--) *str++ = '0';
  while (i-- > 0) *str++ = tmp[i];
  while (size-- > 0) *str++ = ' ';

  return str;
}

static char *eaddr(char *str, unsigned char *addr, int size, int precision, int type)
{
  char tmp[24];
  char *dig = digits;
  int i, len;

  if (type & LARGE)  dig = upper_digits;
  len = 0;
  for (i = 0; i < 6; i++)
  {
    if (i != 0) tmp[len++] = ':';
    tmp[len++] = dig[addr[i] >> 4];
    tmp[len++] = dig[addr[i] & 0x0F];
  }

  if (!(type & LEFT)) while (len < size--) *str++ = ' ';
  for (i = 0; i < len; ++i) *str++ = tmp[i];
  while (len < size--) *str++ = ' ';

  return str;
}

static char *iaddr(char *str, unsigned char *addr, int size, int precision, int type)
{
  char tmp[24];
  int i, n, len;

  len = 0;
  for (i = 0; i < 4; i++)
  {
    if (i != 0) tmp[len++] = '.';
    n = addr[i];
    
    if (n == 0)
      tmp[len++] = digits[0];
    else
    {
      if (n >= 100) 
      {
	tmp[len++] = digits[n / 100];
        n = n % 100;
	tmp[len++] = digits[n / 10];
	n = n % 10;
      }
      else if (n >= 10) 
      {
	tmp[len++] = digits[n / 10];
	n = n % 10;
      }

      tmp[len++] = digits[n];
    }
  }

  if (!(type & LEFT)) while (len < size--) *str++ = ' ';
  for (i = 0; i < len; ++i) *str++ = tmp[i];
  while (len < size--) *str++ = ' ';

  return str;
}
static void cfltcvt(double value, char *buffer, char fmt, int precision)
{
  int decpt, sign, exp, pos;
  char *digits = NULL,*_t;
  char cvtbuf[80];
  int capexp = 0;
  int magnitude;

  if (fmt == 'G' || fmt == 'E')
  {
    capexp = 1;
    fmt += 'a' - 'A';
  }

  if (fmt == 'g')
  {
    digits = ecvtbuf(value, precision, &decpt, &sign, cvtbuf);
    magnitude = decpt - 1;
    if (magnitude < -4  ||  magnitude > precision - 1)
    {
      fmt = 'e';
      precision -= 1;
    }
    else
    {
      fmt = 'f';
      precision -= decpt;
    }
  }

  if (fmt == 'e')
  {
    digits = ecvtbuf(value, precision + 1, &decpt, &sign, cvtbuf);

    if (sign) *buffer++ = '-';
    *buffer++ = *digits;
    if (precision > 0) *buffer++ = '.';
    memcpy(buffer, digits + 1, precision);
    buffer += precision;
    *buffer++ = capexp ? 'E' : 'e';

    if (decpt == 0)
    {
      if (value == 0.0)
	exp = 0;
      else
	exp = -1;
    }
    else
      exp = decpt - 1;

    if (exp < 0)
    {
      *buffer++ = '-';
      exp = -exp;
    }
    else
      *buffer++ = '+';

    buffer[2] = (exp % 10) + '0';
    exp = exp / 10;
    buffer[1] = (exp % 10) + '0';
    exp = exp / 10;
    buffer[0] = (exp % 10) + '0';
    buffer += 3;
  }
  else if (fmt == 'f')
  {
    digits = fcvtbuf(value, precision, &decpt, &sign, cvtbuf);

    if (sign) *buffer++ = '-';
    
    if (*digits)
    {
      if (decpt <= 0)
      {
			*buffer++ = '0';
			*buffer++ = '.';
			for (pos = 0; pos < -decpt; pos++) *buffer++ = '0';
			while (*digits) *buffer++ = *digits++;
      }
      else
      {
			pos = 0;
			while (*digits)
			{
			  if (pos++ == decpt) *buffer++ = '.';
			  *buffer++ = *digits++;
			}
      }
    }
    else
    {
      *buffer++ = '0';
      if (precision > 0)
      {
			*buffer++ = '.';
			for (pos = 0; pos < precision; pos++) *buffer++ = '0';
      }
    }
  }

  *buffer = '\0';
}

static void forcdecpt(char *buffer)
{
  while (*buffer)
  {
    if (*buffer == '.') return;
    if (*buffer == 'e' || *buffer == 'E') break;
    buffer++;
  }

  if (*buffer)
  {
    int n = strlen(buffer);
    while (n > 0) 
    {
      buffer[n + 1] = buffer[n];
      n--;
    }

    *buffer = '.';
  }
  else
  {
    *buffer++ = '.';
    *buffer = '\0';
  }
}

static void cropzeros(char *buffer)
{
  char *stop;

  while (*buffer && *buffer != '.') buffer++;
  if (*buffer++)
  {
    while (*buffer && *buffer != 'e' && *buffer != 'E') buffer++;
    stop = buffer--;
    while (*buffer == '0') buffer--;
    if (*buffer == '.') buffer--;
    while (*++buffer = *stop++);
  }
}

static char *flt(char *str, double num, int size, int precision, char fmt, int flags)
{
  char tmp[80];
  char c, sign;
  int n, i;

  // Left align means no zero padding
  if (flags & LEFT) flags &= ~ZEROPAD;

  // Determine padding and sign char
  c = (flags & ZEROPAD) ? '0' : ' ';
  sign = 0;
  if (flags & SIGN)
  {
    if (num < 0.0)
    {
      sign = '-';
      num = -num;
      size--;
    }
    else if (flags & PLUS)
    {
      sign = '+';
      size--;
    }
    else if (flags & SPACE)
    {
      sign = ' ';
      size--;
    }
  }

  // Compute the precision value
  if (precision < 0)
    precision = 6; // Default precision: 6
  else if (precision == 0 && fmt == 'g')
    precision = 1; // ANSI specified

  // Convert floating point number to text
  cfltcvt(num, tmp, fmt, precision);

  // '#' and precision == 0 means force a decimal point
  if ((flags & SPECIAL) && precision == 0) forcdecpt(tmp);

  // 'g' format means crop zero unless '#' given
  if (fmt == 'g' && !(flags & SPECIAL)) cropzeros(tmp);

  n = strlen(tmp);
  // Output number with alignment and padding
  size -= n;
  if (!(flags & (ZEROPAD | LEFT))) while (size-- > 0) *str++ = ' ';
  if (sign) *str++ = sign;
  if (!(flags & LEFT)) while (size-- > 0) *str++ = c;

  for (i = 0; i < n; i++)
   	*str++ = tmp[i];

  while (size-- > 0) *str++ = ' ';

  return str;
}

int vsprintf(char *buf, const char *fmt, va_list args)
{
  int len;
  unsigned long num;
  int i, base;
  char *str;
  char *s;

  int flags;            // Flags to number()

  int field_width;	// Width of output field
  int precision;	// Min. # of digits for integers; max number of chars for from string
  int qualifier;	// 'h', 'l', or 'L' for integer fields

  for (str = buf; *fmt; fmt++)
  {
    if (*fmt != '%')
    {
      *str++ = *fmt;
      continue;
    }
		  
    // Process flags
    flags = 0;
repeat:
    fmt++; // This also skips first '%'
    switch (*fmt)
    {
      case '-': flags |= LEFT; goto repeat;
      case '+': flags |= PLUS; goto repeat;
      case ' ': flags |= SPACE; goto repeat;
      case '#': flags |= SPECIAL; goto repeat;
      case '0': flags |= ZEROPAD; goto repeat;
    }
	  
    // Get field width
    field_width = -1;
    if (is_digit(*fmt))
      field_width = skip_atoi(&fmt);
    else if (*fmt == '*')
    {
      fmt++;
      field_width = va_arg(args, int);
      if (field_width < 0)
      {
	field_width = -field_width;
	flags |= LEFT;
      }
    }

    // Get the precision
    precision = -1;
    if (*fmt == '.')
    {
      ++fmt;	
      if (is_digit(*fmt))
        precision = skip_atoi(&fmt);
      else if (*fmt == '*')
      {
        ++fmt;
        precision = va_arg(args, int);
      }
      if (precision < 0) precision = 0;
    }

    // Get the conversion qualifier
    qualifier = -1;
    if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L')
    {
      qualifier = *fmt;
      fmt++;
    }

    // Default base
    base = 10;

    switch (*fmt)
    {
      case 'c':
	if (!(flags & LEFT)) while (--field_width > 0) *str++ = ' ';
	*str++ = (unsigned char) va_arg(args, int);
	while (--field_width > 0) *str++ = ' ';
	continue;

      case 's':
	s = va_arg(args, char *);
	if (!s)	s = "<NULL>";
	len = strnlen(s, precision);
	if (!(flags & LEFT)) while (len < field_width--) *str++ = ' ';
	for (i = 0; i < len; ++i) *str++ = *s++;
	while (len < field_width--) *str++ = ' ';
	continue;

      case 'p':
	if (field_width == -1)
	{
	  field_width = 2 * sizeof(void *);
	  flags |= ZEROPAD;
	}
	str = number(str, (unsigned long) va_arg(args, void *), 16, field_width, precision, flags);
	continue;

      case 'n':
	if (qualifier == 'l')
	{
	  long *ip = va_arg(args, long *);
	  *ip = (str - buf);
	}
	else
	{
	  int *ip = va_arg(args, int *);
	  *ip = (str - buf);
	}
	continue;

      case 'A':
	flags |= LARGE;

      case 'a':
	if (qualifier == 'l')
	  str = eaddr(str, va_arg(args, unsigned char *), field_width, precision, flags);
	else
	  str = iaddr(str, va_arg(args, unsigned char *), field_width, precision, flags);
	continue;

      // Integer number formats - set up the flags and "break"
      case 'o':
	base = 8;
	break;

      case 'X':
	flags |= LARGE;

      case 'x':
	base = 16;
	break;

      case 'd':
      case 'i':
	flags |= SIGN;

      case 'u':
	break;

      case 'E':
      case 'G':
      case 'e':
      case 'f':
      case 'g':
        str = flt(str, va_arg(args, double), field_width, precision, *fmt, flags | SIGN);
	continue;

      default:
	if (*fmt != '%') *str++ = '%';
	if (*fmt)
	  *str++ = *fmt;
	else
	  --fmt;
	continue;
    }

    if (qualifier == 'l')
      num = va_arg(args, unsigned long);
    else if (qualifier == 'h')
    {
      if (flags & SIGN)
	num = va_arg(args, short);
      else
	num = va_arg(args, unsigned short);
    }
    else if (flags & SIGN)
      num = va_arg(args, int);
    else
      num = va_arg(args, unsigned int);

    str = number(str, num, base, field_width, precision, flags);
  }

  *str = '\0';
  return str - buf;
}

int sprintf(char *buf, const char *fmt, ...)
{
  va_list args;
  int n;

  va_start(args, fmt);
  n = vsprintf(buf, fmt, args);
  va_end(args);

  return n;
}

int printf(const char *fmt, ...)
{
  char buf[4096];
  va_list args;
  int n;

  va_start(args, fmt);
  n = vsprintf(buf, fmt, args);
  va_end(args);
  
  puts(buf);

  return n;
}
]]>
</file>
<file name="ctype.h">
<![CDATA[
#if _MSC_VER > 1000
#pragma once
#endif

#ifndef CTYPE_H
#define CTYPE_H

#define _UPPER          0x1     // Upper case letter
#define _LOWER          0x2     // Lower case letter
#define _DIGIT          0x4     // Digit[0-9]
#define _SPACE          0x8     // Tab, carriage return, newline, vertical tab or form feed
#define _PUNCT          0x10    // Punctuation character
#define _CONTROL        0x20    // Control character
#define _BLANK          0x40    // Space char
#define _HEX            0x80    // Hexadecimal digit

#define _LEADBYTE       0x8000                      // Multibyte leadbyte
#define _ALPHA          (0x0100 | _UPPER| _LOWER)   // Alphabetic character

#ifdef __cplusplus
extern "C" {
#endif

extern unsigned short *_pctype; // pointer to table for char's

#ifdef __cplusplus
} //extern "C"
#endif

#define isalpha(c)     (_pctype[(unsigned char)(c)] & (_UPPER | _LOWER))
#define isupper(c)     (_pctype[(unsigned char)(c)] & _UPPER)
#define islower(c)     (_pctype[(unsigned char)(c)] & _LOWER)
#define isdigit(c)     (_pctype[(unsigned char)(c)] & _DIGIT)
#define isxdigit(c)    (_pctype[(unsigned char)(c)] & _HEX)
#define isspace(c)     (_pctype[(unsigned char)(c)] & _SPACE)
#define ispunct(c)     (_pctype[(unsigned char)(c)] & _PUNCT)
#define isalnum(c)     (_pctype[(unsigned char)(c)] & (_UPPER | _LOWER | _DIGIT))
#define isprint(c)     (_pctype[(unsigned char)(c)] & (_BLANK | _PUNCT | _UPPER | _LOWER | _DIGIT))
#define isgraph(c)     (_pctype[(unsigned char)(c)] & (_PUNCT | _UPPER | _LOWER | _DIGIT))
#define iscntrl(c)     (_pctype[(unsigned char)(c)] & _CONTROL)
#define isleadbyte(c)  (_pctype[(unsigned char)(c)] & _LEADBYTE)

#define tolower(c)     (isupper((unsigned char)c) ? ((unsigned char)(c) - 'A' + 'a') : (unsigned char)(c))
#define toupper(c)     (islower((unsigned char)c) ? ((unsigned char)(c) - 'a' + 'A') : (unsigned char)(c))

#endif
]]>
</file>
<file name="ctype.c">
<![CDATA[
#include "ctype.h"

unsigned short _ctype[257] = 
{
  0,                      // -1 EOF
  _CONTROL,               // 00 (NUL)
  _CONTROL,               // 01 (SOH)
  _CONTROL,               // 02 (STX)
  _CONTROL,               // 03 (ETX)
  _CONTROL,               // 04 (EOT)
  _CONTROL,               // 05 (ENQ)
  _CONTROL,               // 06 (ACK)
  _CONTROL,               // 07 (BEL)
  _CONTROL,               // 08 (BS)
  _SPACE+_CONTROL,        // 09 (HT)
  _SPACE+_CONTROL,        // 0A (LF)
  _SPACE+_CONTROL,        // 0B (VT)
  _SPACE+_CONTROL,        // 0C (FF)
  _SPACE+_CONTROL,        // 0D (CR)
  _CONTROL,               // 0E (SI)
  _CONTROL,               // 0F (SO)
  _CONTROL,               // 10 (DLE)
  _CONTROL,               // 11 (DC1)
  _CONTROL,               // 12 (DC2)
  _CONTROL,               // 13 (DC3)
  _CONTROL,               // 14 (DC4)
  _CONTROL,               // 15 (NAK)
  _CONTROL,               // 16 (SYN)
  _CONTROL,               // 17 (ETB)
  _CONTROL,               // 18 (CAN)
  _CONTROL,               // 19 (EM)
  _CONTROL,               // 1A (SUB)
  _CONTROL,               // 1B (ESC)
  _CONTROL,               // 1C (FS)
  _CONTROL,               // 1D (GS)
  _CONTROL,               // 1E (RS)
  _CONTROL,               // 1F (US)
  _SPACE+_BLANK,          // 20 SPACE
  _PUNCT,                 // 21 !
  _PUNCT,                 // 22 "
  _PUNCT,                 // 23 #
  _PUNCT,                 // 24 $
  _PUNCT,                 // 25 %
  _PUNCT,                 // 26 &
  _PUNCT,                 // 27 '
  _PUNCT,                 // 28 (
  _PUNCT,                 // 29 )
  _PUNCT,                 // 2A *
  _PUNCT,                 // 2B +
  _PUNCT,                 // 2C ,
  _PUNCT,                 // 2D -
  _PUNCT,                 // 2E .
  _PUNCT,                 // 2F /
  _DIGIT+_HEX,            // 30 0
  _DIGIT+_HEX,            // 31 1
  _DIGIT+_HEX,            // 32 2
  _DIGIT+_HEX,            // 33 3
  _DIGIT+_HEX,            // 34 4
  _DIGIT+_HEX,            // 35 5
  _DIGIT+_HEX,            // 36 6
  _DIGIT+_HEX,            // 37 7
  _DIGIT+_HEX,            // 38 8
  _DIGIT+_HEX,            // 39 9
  _PUNCT,                 // 3A :
  _PUNCT,                 // 3B ;
  _PUNCT,                 // 3C <
  _PUNCT,                 // 3D =
  _PUNCT,                 // 3E >
  _PUNCT,                 // 3F ?
  _PUNCT,                 // 40 @
  _UPPER+_HEX,            // 41 A
  _UPPER+_HEX,            // 42 B
  _UPPER+_HEX,            // 43 C
  _UPPER+_HEX,            // 44 D
  _UPPER+_HEX,            // 45 E
  _UPPER+_HEX,            // 46 F
  _UPPER,                 // 47 G
  _UPPER,                 // 48 H
  _UPPER,                 // 49 I
  _UPPER,                 // 4A J
  _UPPER,                 // 4B K
  _UPPER,                 // 4C L
  _UPPER,                 // 4D M
  _UPPER,                 // 4E N
  _UPPER,                 // 4F O
  _UPPER,                 // 50 P
  _UPPER,                 // 51 Q
  _UPPER,                 // 52 R
  _UPPER,                 // 53 S
  _UPPER,                 // 54 T
  _UPPER,                 // 55 U
  _UPPER,                 // 56 V
  _UPPER,                 // 57 W
  _UPPER,                 // 58 X
  _UPPER,                 // 59 Y
  _UPPER,                 // 5A Z
  _PUNCT,                 // 5B [
  _PUNCT,                 // 5C \ 
  _PUNCT,                 // 5D ]
  _PUNCT,                 // 5E ^
  _PUNCT,                 // 5F _
  _PUNCT,                 // 60 `
  _LOWER+_HEX,            // 61 a
  _LOWER+_HEX,            // 62 b
  _LOWER+_HEX,            // 63 c
  _LOWER+_HEX,            // 64 d
  _LOWER+_HEX,            // 65 e
  _LOWER+_HEX,            // 66 f
  _LOWER,                 // 67 g
  _LOWER,                 // 68 h
  _LOWER,                 // 69 i
  _LOWER,                 // 6A j
  _LOWER,                 // 6B k
  _LOWER,                 // 6C l
  _LOWER,                 // 6D m
  _LOWER,                 // 6E n
  _LOWER,                 // 6F o
  _LOWER,                 // 70 p
  _LOWER,                 // 71 q
  _LOWER,                 // 72 r
  _LOWER,                 // 73 s
  _LOWER,                 // 74 t
  _LOWER,                 // 75 u
  _LOWER,                 // 76 v
  _LOWER,                 // 77 w
  _LOWER,                 // 78 x
  _LOWER,                 // 79 y
  _LOWER,                 // 7A z
  _PUNCT,                 // 7B {
  _PUNCT,                 // 7C |
  _PUNCT,                 // 7D }
  _PUNCT,                 // 7E ~
  _CONTROL,               // 7F (DEL)
  // and the rest are 0...
};

unsigned short *_pctype = _ctype + 1; // pointer to table for char's

]]>
</file>
<file name="init.h">
<![CDATA[
#ifndef __INIT_H
#define __INIT_H

void *operator new(unsigned int size);
void operator delete(void *p);


#ifdef __cplusplus
extern "C" {
#endif

void _init();

#ifdef __cplusplus
} //extern "C"
#endif

#endif
]]>
</file>
<file name="init.cpp">
<![CDATA[
#include "malloc.h"

void *operator new(unsigned int size)
{
	return malloc(size);
}
void operator delete(void *p)
{
	free(p);
}

#ifdef __cplusplus
extern "C" {
#endif

typedef  void (*__FUNC)(void);

extern int main();

void _init()
{
	int i,xcu_size,*p = (int*)0x30000000;
	__FUNC func;	
	
	init_heap((void*)(*(p+2)),(void*)(*(p+3)));

	xcu_size = *(p+4) / 4;
	p = (int *)0x28000000;
	for(i = 0; i < xcu_size; i++)
	{
		func  = (__FUNC)p[i];
		func();
	}
	
	main();
}

#ifdef __cplusplus
} //extern "C"
#endif
]]>
</file>
<file name="limits.h">
<![CDATA[
#if _MSC_VER > 1000
#pragma once
#endif

#ifndef LIMITS_H
#define LIMITS_H

#define PATH_MAX      255
#define ARG_MAX       131072

#define CHAR_BIT      8			// Number of bits in a char
#define SCHAR_MIN   (-128)		// Minimum signed char value
#define SCHAR_MAX     127		// Maximum signed char value
#define UCHAR_MAX     0xff		// Maximum unsigned char value

#ifndef _CHAR_UNSIGNED
#define CHAR_MIN    SCHAR_MIN		// Mimimum char value
#define CHAR_MAX    SCHAR_MAX		// Maximum char value
#else
#define CHAR_MIN      0
#define CHAR_MAX    UCHAR_MAX
#endif

#define MB_LEN_MAX    2			 // Max. # bytes in multibyte char
#define SHRT_MIN    (-32768)		 // Minimum (signed) short value
#define SHRT_MAX      32767		 // Maximum (signed) short value
#define USHRT_MAX     0xffff		 // Maximum unsigned short value
#define INT_MIN     (-2147483647 - 1)	 // Minimum (signed) int value
#define INT_MAX       2147483647	 // Maximum (signed) int value
#define UINT_MAX      0xffffffff	 // Maximum unsigned int value
#define LONG_MIN    (-2147483647L - 1)	 // Minimum (signed) long value
#define LONG_MAX      2147483647L	 // Maximum (signed) long value
#define ULONG_MAX     0xffffffffUL	 // Maximum unsigned long value

#if _INTEGRAL_MAX_BITS >= 8
#define _I8_MIN     (-127i8 - 1)	 // Minimum signed 8 bit value
#define _I8_MAX       127i8		 // Maximum signed 8 bit value
#define _UI8_MAX      0xffui8		 // Maximum unsigned 8 bit value
#endif

#if _INTEGRAL_MAX_BITS >= 16
#define _I16_MIN    (-32767i16 - 1)	 // Minimum signed 16 bit value
#define _I16_MAX      32767i16		 // Maximum signed 16 bit value
#define _UI16_MAX     0xffffui16	 // Maximum unsigned 16 bit value
#endif

#if _INTEGRAL_MAX_BITS >= 32
#define _I32_MIN    (-2147483647i32 - 1) // Minimum signed 32 bit value
#define _I32_MAX      2147483647i32	 // Maximum signed 32 bit value
#define _UI32_MAX     0xffffffffui32	 // Maximum unsigned 32 bit value
#endif

#if _INTEGRAL_MAX_BITS >= 64
#define _I64_MIN    (-9223372036854775807i64 - 1)
#define _I64_MAX      9223372036854775807i64
#define _UI64_MAX     0xffffffffffffffffui64
#endif

#endif
]]>
</file>
<file name="malloc.h">
<![CDATA[
#ifndef __MALLOC_H
#define __MALLOC_H

#include "types.h"

#ifdef __cplusplus
extern "C" {
#endif

void *malloc(DWORD nbytes);
void free(void *ap);
DWORD get_free_size(void);
int init_heap(void *heap_start,void *heap_end);
void *realloc(void *p,DWORD old_size,DWORD new_size);

#ifdef __cplusplus
} //extern "C"
#endif

#endif

]]>
</file>
<file name="malloc.c">
<![CDATA[
#include "malloc.h"
#include "types.h"

typedef DWORD Align;

union header
{
	struct
	{
		union header *ptr;
		DWORD size;
	}s;
	Align x; 
};

typedef union header Header;

static char * __heap_start = NULL;
static char * __heap_end = NULL;

static Header base;  //
static Header *freep=NULL;

static Header *morecore(DWORD nu);

void *malloc(DWORD nbytes)
{
	Header *p, *prevp;
	DWORD nunits;

	nunits = (nbytes+sizeof(Header)-1)/sizeof(Header) + 1;
	
	prevp = freep;
	if(prevp == NULL)
	{
		base.s.ptr = freep = prevp = &base;
		base.s.size=0;
	}
	for(p=prevp->s.ptr ; ;prevp = p,p=p->s.ptr)
	{
		if( p->s.size >= nunits)
		{
			if(p->s.size == nunits)
			{
				prevp->s.ptr = p->s.ptr;
			}
			else
			{
				p->s.size -= nunits;
				p += p->s.size;
				p->s.size = nunits; 
			}
			freep = prevp;
			return (void *)(p+1);
		}
		if(p == freep)
		{
			
			p = morecore(nunits);
			if(p==NULL)
				return NULL;
		}
	}
}

void free(void *ap)
{
	Header *bp, *p;
	
	
	bp = (Header *)ap-1;
	for(p=freep;!(bp > p && bp < p->s.ptr); p=p->s.ptr)
	{
		if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
			break;
	}
	if(bp + bp->s.size == p->s.ptr)
	{
		bp->s.size += p->s.ptr->s.size;
		bp->s.ptr = p->s.ptr->s.ptr;
	}
	else
	{
		bp->s.ptr = p->s.ptr;
	}
	
	if(p + p->s.size == bp)
	{
		p->s.size += bp->s.size;
		p->s.ptr = bp->s.ptr;	
	}
	else
	{
		p->s.ptr = bp;
	}
	freep = p;
}

Header *morecore(DWORD nu)
{
	char *cp;
	Header *up;
	static int is_run = 0;
	
	if(is_run)return NULL;
	is_run = 1;
		
	nu = (__heap_end - __heap_start)/sizeof(Header) - 1;
	
	cp = (char *)__heap_start;
	up = (Header *)cp;
	up->s.size = nu;
	
	free((void *)(up+1));
	
	return freep;
}


DWORD get_free_size()
{
	Header *p, *prevp;
	DWORD size=0;	
	prevp = freep;

	if(prevp == NULL)
	{
		return (__heap_end - __heap_start);
	}

	for(p=prevp->s.ptr ; ;prevp = p,p=p->s.ptr)
	{
		size += p->s.size;
		if(p == freep)
			break;
	}
	return size*sizeof(Header);
}

int init_heap(void *heap_start,void *heap_end)
{
	__heap_start = heap_start;
	__heap_end = heap_end;

	return OK;
}

void *realloc(void *p,DWORD old_size,DWORD new_size)
{
	void *newp;
	DWORD min;
	
	min = old_size<new_size?old_size:new_size;
	
	newp = malloc(new_size);
	
	if(newp == NULL)
		return NULL;
	
	memcpy(newp,p,min);
	
	free(p);
	
	return newp;
}

]]>
</file>
<file name="math.h">
<![CDATA[
#ifndef __MATH_H
#define __MATH_H

#include "float.h"

#define M_E        2.71828182845904523536     // e
#define M_LOG2E    1.44269504088896340736     // log2(e)
#define M_LOG10E   0.434294481903251827651    // log10(e)
#define M_LN2      0.693147180559945309417    // ln(2)
#define M_LN10     2.30258509299404568402     // ln(10)
#define M_PI       3.14159265358979323846     // pi
#define M_PI_2     1.57079632679489661923     // pi/2
#define M_PI_4     0.785398163397448309616    // pi/4
#define M_1_PI     0.318309886183790671538    // 1/pi
#define M_2_PI     0.636619772367581343076    // 2/pi
#define M_2_SQRTPI 1.12837916709551257390     // 2/sqrt(pi)
#define M_SQRT2    1.41421356237309504880     // sqrt(2)
#define M_SQRT1_2  0.707106781186547524401    // 1/sqrt(2)

#define HUGE_VAL _infinity

//
// Floating point classes for fpclassify()
//

#define FP_NAN       0
#define FP_INFINITE  1
#define FP_ZERO      2
#define FP_SUBNORMAL 3
#define FP_NORMAL    4

#ifdef __cplusplus
extern "C" {
#endif

extern const double _infinity;

double acos(double x);  //test ok
double asin(double x);  //test ok
double atan(double x);	//test ok
double atan2(double x, double y); //test ok
double ceil(double x); //test ok
double cos(double x);	//test ok
double cosh(double x);	//test ok
double exp(double x);	//test ok
double fabs(double x);	//test ok
double floor(double x); //test ok
double fmod(double x, double y);//test ok
double frexp(double x, int *n);	//test ok
double ldexp(double x, int n);	//test ok
double log(double x);	//test ok
double log10(double x);	//test ok
double modf(double x, double *y);	//test ok
double pow(double x, double y);	//test ok
double sin(double x);	//test ok
double sinh(double x);	//test ok
double sqrt(double x);	//test ok
double tan(double x);	//test ok
double tanh(double x);	//test ok

#ifdef __cplusplus
} //extern "C"
#endif

#endif
]]>
</file>
<file name="math.c">
<![CDATA[
#include "math.h"

struct dblval
{
  unsigned int manl:32;
  unsigned int manh:20;
  unsigned int exp:11;
  unsigned int sign:1;
};

int isinf(double x) 
{
  unsigned __int64 *val = (unsigned __int64 *) &x;

  return *val == 0x7ff0000000000000 ? 1 : *val == 0xfff0000000000000 ? -1 : 0;
}

int isnan(double x)
{
  return x != x;
}

int isfinite(double x)
{
  unsigned short *val = (unsigned short *) &x;

  return (val[3] & 0x7ff0) != 0x7ff0;
}

int _fpclass(double x)
{
  struct dblval *d = (struct dblval *) &x;
  
  if (d->exp == 0)
  {
    if (d->manh == 0 && d->manl == 0)
    {
      if (d->sign == 0)
        return _FPCLASS_NZ;
      else
        return _FPCLASS_PZ;
    } 
    else 
    {
      if (d->sign == 0)
        return _FPCLASS_ND;
      else
        return _FPCLASS_PD;
    }
  }

  if (d->exp == 0x7ff)
  {
    if (d->manh == 0 && d->manl == 0)
    {
      if (d->sign == 0)
        return _FPCLASS_NINF;
      else
        return _FPCLASS_PINF;
    }
    else if (d->manh == 0 && d->manl != 0) 
      return _FPCLASS_QNAN;
    else
      return _FPCLASS_SNAN;
  }

  return 0;
}

int fpclassify(double x)
{
  struct dblval *d = (struct dblval *) &x;

  if (d->exp == 0) 
  {
    if ((d->manl | d->manh) == 0) return FP_ZERO;
    return (FP_SUBNORMAL);
  }
  
  if (d->exp == 0x7ff) 
  {
    if ((d->manl | d->manh) == 0) return FP_INFINITE;
    return FP_NAN;
  
  }
  
  return FP_NORMAL;
}

int isless(double x, double y)
{
  return isfinite(x) && isfinite(y) ? x < y : 0;
}

int isgreater(double x, double y)
{
  return isfinite(x) && isfinite(y) ? x > y : 0;
}

double round(double x)
{
  double t;

  if (!isfinite(x)) return x;

  if (x >= 0.0) 
  {
    t = ceil(x);
    if (t - x > 0.5) t -= 1.0;
    return t;
  } 
  else 
  {
    t = ceil(-x);
    if (t + x > 0.5) t -= 1.0;
    return -t;
  }
}
]]>
</file>
<file name="float.h">
<![CDATA[
#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _FLOAT_H
#define _FLOAT_H

//
// Limits for float
//

#define FLT_RADIX      2
#define FLT_ROUNDS     1
#define FLT_DIG        6
#define FLT_EPSILON    1.192092896e-07F
#define FLT_MANT_DIG   24
#define FLT_MAX        3.402823466e+38F
#define FLT_MAX_10_EXP 38
#define FLT_MAX_EXP    128
#define FLT_MIN        1.175494351e-38F
#define FLT_MIN_10_EXP (-37)
#define FLT_MIN_EXP    (-125)

//
// Limits for double
//

#define DBL_DIG        15
#define DBL_EPSILON    2.2204460492503131e-016
#define DBL_MANT_DIG   53
#define DBL_MAX        1.7976931348623158e+308
#define DBL_MAX_10_EXP 308
#define DBL_MAX_EXP    1024
#define DBL_MIN        2.2250738585072014e-308
#define DBL_MIN_10_EXP (-307)
#define DBL_MIN_EXP    (-1021)

//
// Floating point classes for _fpclass()
//

#define _FPCLASS_SNAN   0x0001  // Signaling NaN
#define _FPCLASS_QNAN   0x0002  // Quiet NaN
#define _FPCLASS_NINF   0x0004  // Negative infinity
#define _FPCLASS_NN     0x0008  // Negative normal
#define _FPCLASS_ND     0x0010  // Negative denormal
#define _FPCLASS_NZ     0x0020  // -0
#define _FPCLASS_PZ     0x0040  // +0
#define _FPCLASS_PD     0x0080  // Positive denormal
#define _FPCLASS_PN     0x0100  // Positive normal
#define _FPCLASS_PINF   0x0200  // Positive infinity

#endif
]]>
</file>
<file name="stdarg.h">
<![CDATA[
#if _MSC_VER > 1000
#pragma once
#endif

#ifndef STDARG_H
#define STDARG_H

#ifndef _VA_LIST_DEFINED
#define _VA_LIST_DEFINED
typedef char *va_list;
#endif

#define _INTSIZEOF(n)    ((sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1))

#define va_start(ap, v)  (ap = (va_list) &v + _INTSIZEOF(v))
#define va_arg(ap, t)    (*(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))
#define va_end(ap)       (ap = (va_list) 0)

#endif

]]>
</file>
<file name="stdlib.h">
<![CDATA[
#ifndef __STDLIB_H
#define __STDLIB_H

#ifdef  __cplusplus
extern "C" {
#endif

int atoi(const char *string);
long atol(const char *string);
double strtod(const char *str, char **endptr);
double atof(const char *str);
int hex2dec_32(char *shex);

#ifdef  __cplusplus
}
#endif

#endif
]]>
</file>
<file name="stdlib.c">
<![CDATA[
#include "stdlib.h"
#include "math.h"
#include "ctype.h"
#include "limits.h"
#include "types.h"
#include "string.h"

#define FL_UNSIGNED   1
#define FL_NEG        2
#define FL_OVERFLOW   4
#define FL_READDIGIT  8

#define CVTBUFSIZE        (309 + 43)

static char *cvt(double arg, int ndigits, int *decpt, int *sign, char *buf, int eflag)
{
  int r2;
  double fi, fj;
  char *p, *p1;

  if (ndigits < 0) ndigits = 0;
  if (ndigits >= CVTBUFSIZE - 1) ndigits = CVTBUFSIZE - 2;
  r2 = 0;
  *sign = 0;
  p = &buf[0];
  if (arg < 0)
  {
    *sign = 1;
    arg = -arg;
  }
  arg = modf(arg, &fi);
  p1 = &buf[CVTBUFSIZE];

  if (fi != 0) 
  {
    p1 = &buf[CVTBUFSIZE];
    while (fi != 0) 
    {
      fj = modf(fi / 10, &fi);
      *--p1 = (int)((fj + .03) * 10) + '0';
      r2++;
    }
    while (p1 < &buf[CVTBUFSIZE]) *p++ = *p1++;
  } 
  else if (arg > 0)
  {
    while ((fj = arg * 10) < 1) 
    {
      arg = fj;
      r2--;
    }
  }
  p1 = &buf[ndigits];
  if (eflag == 0) p1 += r2;
  *decpt = r2;
  if (p1 < &buf[0]) 
  {
    buf[0] = '\0';
    return buf;
  }
  while (p <= p1 && p < &buf[CVTBUFSIZE])
  {
    arg *= 10;
    arg = modf(arg, &fj);
    *p++ = (int) fj + '0';
  }
  if (p1 >= &buf[CVTBUFSIZE]) 
  {
    buf[CVTBUFSIZE - 1] = '\0';
    return buf;
  }
  p = p1;
  *p1 += 5;
  while (*p1 > '9') 
  {
    *p1 = '0';
    if (p1 > buf)
      ++*--p1;
    else 
    {
      *p1 = '1';
      (*decpt)++;
      if (eflag == 0) 
      {
	if (p > buf) *p = '0';
	p++;
      }
    }
  }
  *p = '\0';
  return buf;
}

char *ecvtbuf(double arg, int ndigits, int *decpt, int *sign, char *buf)
{
  return cvt(arg, ndigits, decpt, sign, buf, 1);
}

char *fcvtbuf(double arg, int ndigits, int *decpt, int *sign, char *buf)
{
  return cvt(arg, ndigits, decpt, sign, buf, 0);
}

static unsigned long strtoxl(const char *nptr, char **endptr, int ibase, int flags)
{
  const char *p;
  char c;
  unsigned long number;
  unsigned digval;
  unsigned long maxval;

  p = nptr;
  number = 0;

  c = *p++;
  while (isspace((int)(unsigned char) c)) c = *p++;

  if (c == '-') 
  {
    flags |= FL_NEG;
    c = *p++;
  }
  else if (c == '+')
    c = *p++;

  if (ibase < 0 || ibase == 1 || ibase > 36) 
  {
    if (endptr) *endptr = (char *) nptr;
    return 0L;
  }
  else if (ibase == 0)
  {
    if (c != '0')
      ibase = 10;
    else if (*p == 'x' || *p == 'X')
      ibase = 16;
    else
      ibase = 8;
  }

  if (ibase == 16)
  {
    if (c == '0' && (*p == 'x' || *p == 'X')) 
    {
      ++p;
      c = *p++;
    }
  }

  maxval = ULONG_MAX / ibase;

  for (;;) 
  {
    if (isdigit((int) (unsigned char) c))
      digval = c - '0';
    else if (isalpha((int) (unsigned char) c))
      digval = toupper(c) - 'A' + 10;
    else
      break;

    if (digval >= (unsigned) ibase) break;

    flags |= FL_READDIGIT;

    if (number < maxval || (number == maxval && (unsigned long) digval <= ULONG_MAX % ibase)) 
      number = number * ibase + digval;
    else 
      flags |= FL_OVERFLOW;

    c = *p++;
  }

  --p;

  if (!(flags & FL_READDIGIT)) 
  {
    if (endptr) p = nptr;
    number = 0L;
  }
  else if ((flags & FL_OVERFLOW) || (!(flags & FL_UNSIGNED) && (((flags & FL_NEG) && (number < LONG_MIN)) || (!(flags & FL_NEG) && (number > LONG_MAX)))))
  {
    if (flags & FL_UNSIGNED)
      number = ULONG_MAX;
    else if (flags & FL_NEG)
      number = LONG_MIN;
    else
      number = LONG_MAX;
  }

  if (endptr != NULL) *endptr = (char *) p;

  if (flags & FL_NEG) number = (unsigned long) (-(long) number);

  return number;
}

long strtol(const char *nptr, char **endptr, int ibase)
{
  return (long) strtoxl(nptr, endptr, ibase, 0);
}

unsigned long strtoul(const char *nptr, char **endptr, int ibase)
{
  return strtoxl(nptr, endptr, ibase, FL_UNSIGNED);
}

long atol(const char *nptr)
{
  int c;
  long total;
  int sign;

  while (isspace((int)(unsigned char) *nptr)) ++nptr;

  c = (int)(unsigned char) *nptr++;
  sign = c;
  if (c == '-' || c == '+') c = (int)(unsigned char) *nptr++;

  total = 0;
  while (isdigit(c)) 
  {
    total = 10 * total + (c - '0');
    c = (int)(unsigned char) *nptr++;
  }

  if (sign == '-')
    return -total;
  else
    return total;
}

int atoi(const char *nptr)
{
  return (int) atol(nptr);
}

double strtod(const char *str, char **endptr)
{
  double number;
  int exponent;
  int negative;
  char *p = (char *) str;
  double p10;
  int n;
  int num_digits;
  int num_decimals;

  // Skip leading whitespace
  while (isspace(*p)) p++;

  // Handle optional sign
  negative = 0;
  switch (*p) 
  {		
    case '-': negative = 1; // Fall through to increment position
    case '+': p++;
  }

  number = 0.;
  exponent = 0;
  num_digits = 0;
  num_decimals = 0;

  // Process string of digits
  while (isdigit(*p))
  {
    number = number * 10. + (*p - '0');
    p++;
    num_digits++;
  }

  // Process decimal part
  if (*p == '.') 
  {
    p++;

    while (isdigit(*p))
    {
      number = number * 10. + (*p - '0');
      p++;
      num_digits++;
      num_decimals++;
    }

    exponent -= num_decimals;
  }

  if (num_digits == 0)
  {
    return 0.0;
  }

  // Correct for sign
  if (negative) number = -number;

  // Process an exponent string
  if (*p == 'e' || *p == 'E') 
  {
    // Handle optional sign
    negative = 0;
    switch (*++p) 
    {	
      case '-': negative = 1;	// Fall through to increment pos
      case '+': p++;
    }

    // Process string of digits
    n = 0;
    while (isdigit(*p)) 
    {	
      n = n * 10 + (*p - '0');
      p++;
    }

    if (negative) 
      exponent -= n;
    else
      exponent += n;
  }

  if (exponent < DBL_MIN_EXP  || exponent > DBL_MAX_EXP)
  {
    return HUGE_VAL;
  }

  // Scale the result
  p10 = 10.;
  n = exponent;
  if (n < 0) n = -n;
  while (n) 
  {
    if (n & 1) 
    {
      if (exponent < 0)
        number /= p10;
      else
	number *= p10;
    }
    n >>= 1;
    p10 *= p10;
  }
  
  if (endptr) *endptr = p;

  return number;
}

double atof(const char *str)
{
  return strtod(str, NULL);
}

int hex2dec_32(char *shex)
{
	int idec,i,mid;   
	int len;	
    
	while(shex[0] == '0')
		shex ++;
    
	len = strlen( shex );   

	mid = 0;   idec = 0;   
	
	for( i=0; i<len; i++ )   
	{   
		if( shex[i]>='0'&&shex[i]<='9' )   
			mid = shex[i]-'0';   
		else if( shex[i]>='a'&&shex[i]<='f' )   
			mid   =   shex[i]   -'a'   +10;   
		else if( shex[i]>='A'&&shex[i]<='F' )   
			mid = shex[i]   -'A'   +10;   
		else   
			return   0;   
		
		mid = mid << ((len-i-1)<<2);   
		idec  = idec | mid;   		
	}   
    
	return idec;   
}

]]>
</file>
<file name="string.h">
<![CDATA[
#ifndef __STRING_2007_12_6_14_52_56_H
#define __STRING_2007_12_6_14_52_56_H

#include "ctype.h"
#include "types.h"

#ifdef __cplusplus
extern "C" {
#endif

int stricmp(const char *s1, const char *s2);
char *strchr(const char *s, int ch);
char *strstr(const char *str1, const char *str2);
void *memcpy(void *dst, const void *src, size_t n);
char *strcpy(char *dst, const char *src);
size_t strlen(const char *s);
int strcmp(const char *s1, const char *s2);
char *strcat(char *dst, const char *src);
void *memset(void *p, int c, size_t n);
char *strlwr(char *s);
char *strupr(char *s);

#ifdef __cplusplus
} //extern "C"
#endif
	
#endif
]]>
</file>
<file name="string.c">
<![CDATA[
#include "string.h"

int stricmp(const char *s1, const char *s2)
{
	char f, l;
	
	do 
	{
		f = ((*s1 <= 'Z') && (*s1 >= 'A')) ? *s1 + 'a' - 'A' : *s1;
		l = ((*s2 <= 'Z') && (*s2 >= 'A')) ? *s2 + 'a' - 'A' : *s2;
		s1++;
		s2++;
	} while ((f) && (f == l));
	
	return (int) (f - l);
}

char *strchr(const char *s, int ch)
{
	while (*s && *s != (char) ch) s++;
	if (*s == (char) ch) return (char *) s;
	return NULL;
}

char *strstr(const char *str1, const char *str2)
{
	char *cp = (char *) str1;
	char *s1, *s2;
	
	if (!*str2) return (char *) str1;
	
	while (*cp)
	{
		s1 = cp;
		s2 = (char *) str2;
		
		while (*s1 && *s2 && !(*s1 - *s2)) s1++, s2++;
		if (!*s2) return cp;
		cp++;
	}
	
	return NULL;
}
char *strlwr(char *s)
{
  char *p = s;

  while (*p)
  {
    *p = (char) tolower(*p);
    p++;
  }

  return s;
}

char *strupr(char *s)
{
  char *p = s;

  while (*p)
  {
    *p = (char) toupper(*p);
    p++;
  }

  return s;
}

]]>
</file>
<file name="types.h">
<![CDATA[
#if _MSC_VER > 1000
#pragma once
#endif

#ifndef SYS_TYPES_H
#define SYS_TYPES_H

#ifndef _SIZE_T_DEFINED
#define _SIZE_T_DEFINED
typedef unsigned int size_t;
#endif

#ifndef _SSIZE_T_DEFINED
#define _SSIZE_T_DEFINED
typedef int ssize_t;
#endif

#ifndef _TIME_T_DEFINED
#define _TIME_T_DEFINED
typedef long time_t;
#endif

#ifndef _CLOCK_T_DEFINED
#define _CLOCK_T_DEFINED
typedef long clock_t;
#endif

#ifndef _INO_T_DEFINED
#define _INO_T_DEFINED
typedef unsigned int ino_t;
#endif

#ifndef _DEV_T_DEFINED
#define _DEV_T_DEFINED
typedef unsigned int dev_t;
#endif

#ifndef _MODE_T_DEFINED
#define _MODE_T_DEFINED
typedef unsigned short mode_t;
#endif

#ifndef _NLINK_T_DEFINED
#define _NLINK_T_DEFINED
typedef unsigned short nlink_t;
#endif

#ifndef _UID_T_DEFINED
#define _UID_T_DEFINED
typedef unsigned short uid_t;
#endif

#ifndef _GID_T_DEFINED
#define _GID_T_DEFINED
typedef unsigned short gid_t;
#endif

#ifndef _BLKNO_T_DEFINED
#define _BLKNO_T_DEFINED
typedef unsigned int blkno_t;
#endif

#ifndef _LOFF_T_DEFINED
#define _LOFF_T_DEFINED
typedef long loff_t;
#endif

#ifndef _OFF64_T_DEFINED
#define _OFF64_T_DEFINED
typedef __int64 off64_t;
#endif

#ifndef _OFF_T_DEFINED
#define _OFF_T_DEFINED
#ifdef LARGEFILES
typedef off64_t off_t;
#else
typedef loff_t off_t;
#endif
#endif

#ifndef _HANDLE_T_DEFINED
#define _HANDLE_T_DEFINED
typedef int handle_t;
#endif

#ifndef _TID_T_DEFINED
#define _TID_T_DEFINED
typedef unsigned long tid_t;
#endif

#ifndef _PID_T_DEFINED
#define _PID_T_DEFINED
typedef unsigned long pid_t;
#endif

#ifndef _HMODULE_T_DEFINED
#define _HMODULE_T_DEFINED
typedef void *hmodule_t;
#endif

#ifndef _TLS_T_DEFINED
#define _TLS_T_DEFINED
typedef unsigned long tls_t;
#endif

#ifndef _WCHAR_T_DEFINED
#define _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#endif

#ifndef _VA_LIST_DEFINED
#define _VA_LIST_DEFINED
typedef char *va_list;
#endif

typedef int port_t;
typedef int err_t;

typedef __int64 systime_t;

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

#ifndef _ONLY_STD_TYPES

#ifndef osapi
#ifdef OS_LIB
#define osapi __declspec(dllexport)
#else
#ifdef KERNEL
#define osapi
#else
#define osapi __declspec(dllimport)
#endif
#endif
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE  1
#endif

#ifndef OK
#define OK    1
#endif

#ifndef ERROR
#define ERROR 0
#endif

#ifndef NOHANDLE
#define NOHANDLE ((handle_t) -1)
#endif

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef unsigned __int64 QWORD;
typedef BYTE BOOL;

typedef BYTE BOOL;
typedef int LONG;
typedef char CHAR;

#endif

#endif
]]>
</file>
<file name="time.h">
<![CDATA[
#ifndef TIME_H
#define TIME_H

#include "types.h"

#define CLOCKS_PER_SEC  1000

struct tm
{
  int tm_sec;			// Seconds after the minute [0, 59]
  int tm_min;			// Minutes after the hour [0, 59]
  int tm_hour;			// Hours since midnight [0, 23]
  int tm_mday;			// Day of the month [1, 31]
  int tm_mon;			// Months since January [0, 11]
  int tm_year;			// Years since 1900
  int tm_wday;			// Days since Sunday [0, 6]
  int tm_yday;			// Days since January 1 [0, 365]
  int tm_isdst;			// Daylight Saving Time flag
  int tm_gmtoff;                // Seconds east of UTC
  char *tm_zone;                // Timezone abbreviation
};


struct timeval 
{
  long tv_sec;		        // Seconds
  long tv_usec;		        // Microseconds
};


struct timezone 
{
  int tz_minuteswest;	        // Minutes west of Greenwich
  int tz_dsttime;	        // Type of daylight saving correction
};


extern int _daylight;     // Non-zero if daylight savings time is used
extern long _dstbias;     // Offset for Daylight Saving Time
extern long _timezone;    // Difference in seconds between GMT and local time
extern char *_tzname[2];  // Standard/daylight savings time zone names

#define difftime(time2, time1) ((double)((time2) - (time1)))

#ifdef  __cplusplus
extern "C" {
#endif

struct tm *gmtime_r(const time_t *timer, struct tm *tmbuf);
struct tm *localtime_r(const time_t *timer, struct tm *tmbuf);
time_t mktime(struct tm *tmbuf);

void long_to_time(time_t timer,struct tm *tmbuf);
time_t time_to_long(struct tm *tmbuf);

#ifdef  __cplusplus
}
#endif

#endif

]]>
</file>
<file name="time.c">
<![CDATA[
#include "time.h"

#define	YEAR0		        1900
#define	EPOCH_YR	        1970
#define	SECS_DAY	        (24L * 60L * 60L)
#define	LEAPYEAR(year)	        (!((year) % 4) && (((year) % 100) || !((year) % 400)))
#define	YEARSIZE(year)	        (LEAPYEAR(year) ? 366 : 365)
#define	FIRSTSUNDAY(timp)       (((timp)->tm_yday - (timp)->tm_wday + 420) % 7)
#define	FIRSTDAYOF(timp)        (((timp)->tm_wday - (timp)->tm_yday + 420) % 7)

#define TIME_MAX                2147483647L

int _daylight = 0;                  // Non-zero if daylight savings time is used
long _dstbias = 0;                  // Offset for Daylight Saving Time
long _timezone = -8*3600;           // Difference in seconds between GMT and local time
char *_tzname[2] = {"GMT", "GMT"};  // Standard/daylight savings time zone names

const char *_days[] = 
{
  "Sunday", "Monday", "Tuesday", "Wednesday",
  "Thursday", "Friday", "Saturday"
};

const char *_days_abbrev[] = 
{
  "Sun", "Mon", "Tue", "Wed", 
  "Thu", "Fri", "Sat"
};

const char *_months[] = 
{
  "January", "February", "March",
  "April", "May", "June",
  "July", "August", "September",
  "October", "November", "December"
};

const char *_months_abbrev[] = 
{
  "Jan", "Feb", "Mar",
  "Apr", "May", "Jun",
  "Jul", "Aug", "Sep",
  "Oct", "Nov", "Dec"
};

const int _ytab[2][12] = 
{
  {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
  {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};

struct tm *gmtime_r(const time_t *timer, struct tm *tmbuf)
{
  time_t time = *timer;
  unsigned long dayclock, dayno;
  int year = EPOCH_YR;

  dayclock = (unsigned long) time % SECS_DAY;
  dayno = (unsigned long) time / SECS_DAY;

  tmbuf->tm_sec = dayclock % 60;
  tmbuf->tm_min = (dayclock % 3600) / 60;

  tmbuf->tm_hour = dayclock / 3600;
  tmbuf->tm_wday = (dayno + 4) % 7; // Day 0 was a thursday
  while (dayno >= (unsigned long) YEARSIZE(year)) 
  {
    dayno -= YEARSIZE(year);
    year++;
  }
  tmbuf->tm_year = year - YEAR0;
  tmbuf->tm_yday = dayno;
  tmbuf->tm_mon = 0;
  while (dayno >= (unsigned long) _ytab[LEAPYEAR(year)][tmbuf->tm_mon]) 
  {
    dayno -= _ytab[LEAPYEAR(year)][tmbuf->tm_mon];
    tmbuf->tm_mon++;
  }
  tmbuf->tm_mday = dayno + 1;
  tmbuf->tm_isdst = 0;
  tmbuf->tm_gmtoff = 0;
  tmbuf->tm_zone = "UTC";
  return tmbuf;
}

struct tm *localtime_r(const time_t *timer, struct tm *tmbuf)
{
  time_t t;

  t = *timer - _timezone;
  return gmtime_r(&t, tmbuf);
}

time_t mktime(struct tm *tmbuf)
{
  long day, year;
  int tm_year;
  int yday, month;
  /*unsigned*/ long seconds;
  int overflow;
  long dst;

  tmbuf->tm_min += tmbuf->tm_sec / 60;
  tmbuf->tm_sec %= 60;
  if (tmbuf->tm_sec < 0) 
  {
    tmbuf->tm_sec += 60;
    tmbuf->tm_min--;
  }
  tmbuf->tm_hour += tmbuf->tm_min / 60;
  tmbuf->tm_min = tmbuf->tm_min % 60;
  if (tmbuf->tm_min < 0) 
  {
    tmbuf->tm_min += 60;
    tmbuf->tm_hour--;
  }
  day = tmbuf->tm_hour / 24;
  tmbuf->tm_hour= tmbuf->tm_hour % 24;
  if (tmbuf->tm_hour < 0) 
  {
    tmbuf->tm_hour += 24;
    day--;
  }
  tmbuf->tm_year += tmbuf->tm_mon / 12;
  tmbuf->tm_mon %= 12;
  if (tmbuf->tm_mon < 0) 
  {
    tmbuf->tm_mon += 12;
    tmbuf->tm_year--;
  }
  day += (tmbuf->tm_mday - 1);
  while (day < 0) 
  {
    if(--tmbuf->tm_mon < 0) 
    {
      tmbuf->tm_year--;
      tmbuf->tm_mon = 11;
    }
    day += _ytab[LEAPYEAR(YEAR0 + tmbuf->tm_year)][tmbuf->tm_mon];
  }
  while (day >= _ytab[LEAPYEAR(YEAR0 + tmbuf->tm_year)][tmbuf->tm_mon]) 
  {
    day -= _ytab[LEAPYEAR(YEAR0 + tmbuf->tm_year)][tmbuf->tm_mon];
    if (++(tmbuf->tm_mon) == 12) 
    {
      tmbuf->tm_mon = 0;
      tmbuf->tm_year++;
    }
  }
  tmbuf->tm_mday = day + 1;
  year = EPOCH_YR;
  if (tmbuf->tm_year < year - YEAR0) return (time_t) -1;
  seconds = 0;
  day = 0;			// Means days since day 0 now
  overflow = 0;

  // Assume that when day becomes negative, there will certainly
  // be overflow on seconds.
  // The check for overflow needs not to be done for leapyears
  // divisible by 400.
  // The code only works when year (1970) is not a leapyear.
  tm_year = tmbuf->tm_year + YEAR0;

  if (TIME_MAX / 365 < tm_year - year) overflow++;
  day = (tm_year - year) * 365;
  if (TIME_MAX - day < (tm_year - year) / 4 + 1) overflow++;
  day += (tm_year - year) / 4 + ((tm_year % 4) && tm_year % 4 < year % 4);
  day -= (tm_year - year) / 100 + ((tm_year % 100) && tm_year % 100 < year % 100);
  day += (tm_year - year) / 400 + ((tm_year % 400) && tm_year % 400 < year % 400);

  yday = month = 0;
  while (month < tmbuf->tm_mon)
  {
    yday += _ytab[LEAPYEAR(tm_year)][month];
    month++;
  }
  yday += (tmbuf->tm_mday - 1);
  if (day + yday < 0) overflow++;
  day += yday;

  tmbuf->tm_yday = yday;
  tmbuf->tm_wday = (day + 4) % 7;		// Day 0 was thursday (4)

  seconds = ((tmbuf->tm_hour * 60L) + tmbuf->tm_min) * 60L + tmbuf->tm_sec;

  if ((TIME_MAX - seconds) / SECS_DAY < day) overflow++;
  seconds += day * SECS_DAY;

  // Now adjust according to timezone and daylight saving time
  if (((_timezone > 0) && (TIME_MAX - _timezone < seconds))
      || ((_timezone < 0) && (seconds < -_timezone)))
	  overflow++;
  seconds += _timezone;

  if (tmbuf->tm_isdst)
    dst = _dstbias;
  else 
    dst = 0;

  if (dst > seconds) overflow++;	// dst is always non-negative
  seconds -= dst;

  if (overflow) return (time_t) -1;

  if ((time_t) seconds != seconds) return (time_t) -1;
  return (time_t) seconds;
}

void long_to_time(time_t timer,struct tm *tmbuf)
{
	localtime_r(&timer,tmbuf);
	
	tmbuf->tm_year += YEAR0;
	tmbuf->tm_mon += 1;
}

time_t time_to_long(struct tm *tmbuf)
{
	struct tm local;
		
	local.tm_year = tmbuf->tm_year - YEAR0;
	local.tm_mon = tmbuf->tm_mon - 1;
	local.tm_mday = tmbuf->tm_mday;
	local.tm_hour = tmbuf->tm_hour;
	local.tm_min = tmbuf->tm_min;
	local.tm_sec = tmbuf->tm_sec;
	
	return mktime(&local);
}
]]>
</file>

</RunTime>
<File>


<file name="filebase.h">
<![CDATA[
// FileBase.h: interface for the CFileBase class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILEBASE_H__BD546014_EE30_43B6_90BB_2EE15AD02697__INCLUDED_)
#define AFX_FILEBASE_H__BD546014_EE30_43B6_90BB_2EE15AD02697__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "common.h"

class CFileBase
{

public:
	char *file_name;
	char *sp_chars;
	char *except_sp_chars;
public:
	int Split(CFileBase *file);
	int ReadLine(int line_index,CFileBase *file);
	int Puts(CFileBase *file_str);
	int ReadLeftStr(CFileBase *file,int skip_empty);
	int StdStr();
	int StartWith(char *str,int case_sensive,int skip_empty);
	int StartWith(CFileBase *file_str,int case_sensive,int skip_empty);
	int StrCpy(char *str);
	int StrCpy(CFileBase *file);
	int StrICmp(char *str);
	int StrICmp(CFileBase *file);
	int StrCmp(CFileBase *file);
	int StrCat(CFileBase *file);
	int StrCmp(char *str);
	int StrCat(char *str);
	int StrLen();
	int SearchWordsList(char *words_list,int case_sensive);
	static int InStrList(char *str, char *str_list, int case_sensive);
	int ReadQuoteStr(char escape_char,char end_char,CFileBase *file);
	int Getc_GB(char *letter);
	int ReadCStr(CFileBase *file);
	int ReplaceStr(char *src_str,char *des_str,int case_sensive,int word_only,CFileBase *new_file);
	int SearchStr(char *str,int case_sensive,int word_only);
	int SetFileName(char *fn);
	char GetLastChar(int empty_included);
	int ReadString_Reverse(CFileBase *file);
	int Reverse(long start,long end);
	int SetChar(long index,char ch);
	char CharAt(long index);
	int ReadWord_Reverse(CFileBase *file);
	int ReadWordWithEmptyChar_Reverse(CFileBase *file);
	int SkipEmptyChars_Reverse();
	int SetSplitChars(char *sp_str);
	static int IsEmptyChar(char ch);
	char UnGetc();
	int Dump();
	int IsSpChar(char ch);
	int Puts(char *str);
	int ReadLine(CFileBase *file);
	int ReadString(CFileBase *file);
	int ReadWord(CFileBase *file);
	int ReadWordWithEmptyChar(CFileBase *file);
	int SetDefaultSpChars();
	int SkipEmptyChars();
	int UnPutc();
	int ReadLine_Reverse();
	int ReadLine_Reverse(CFileBase *file);
	int Printf(char *szFormat, ...);
	//common part

public:
	char Getc();
	int Putc(char ch);
	int SearchBin(CFileBase *file_bin);
	long WriteFile(CFileBase *file, long start, long ws,void *buf,int buf_size);
	long WriteToFile(CFileBase *file,long start,long wsize,void *buf,int buf_size);
	int WriteToFile(CFileBase *file);
	int SeekEnd();
	int AdjustOffset();
	int FillBlock(long fill_size,char fill_ch);
	int Destroy();
	int Init();
	int ExpandFromOff(long exp_size);
	int SeekBack(long back_bytes);
	int Insert(CFileBase *file);
	int Delete(long del_size);
	int IsEnd();
	long WriteFile(CFileBase *file);
	long WriteFile(CFileBase *file, long start, long ws);
	long WriteToFile(CFileBase *file,long wsize);
	long WriteToFile(CFileBase *file,long start,long wsize);
	CFileBase();
	virtual ~CFileBase();
	///////need implement by child class////////
	virtual long GetOffset() = 0;
	virtual long GetSize() = 0;
	virtual long Read(void *buf,long n) = 0;
	virtual long Write(void *buf,long n) = 0;
	virtual int SetSize(long ssize) = 0;
	virtual int Seek(long off) = 0;
	virtual int AddBlock(long bsize) = 0;
	virtual long GetMaxSize() = 0;
};

#endif // !defined(AFX_FILEBASE_H__BD546014_EE30_43B6_90BB_2EE15AD02697__INCLUDED_)
]]>
</file>

<file name="filebase.cpp">
<![CDATA[
#include "stdafx.h"
#include "filebase.h"
#include "mem.h"

///////////////////////////////////////////////////////////////////
//common part
///////////////////////////////////////////////////////////////////
CFileBase::CFileBase()
{
	this->Init();
}

CFileBase::~CFileBase()
{
	this->Destroy();
}
char CFileBase::Getc()
{
	char ch = 0;
	
	this->Read(&ch,1);

	return ch;
}
int CFileBase::Putc(char ch)
{
	return this->Write(&ch,1);
}
int CFileBase::SearchBin(CFileBase *file_bin)
{
	ASSERT(file_bin);
	int old;
	char ch1,ch2;

	file_bin->Seek(0);

	while(!this->IsEnd())
	{
		old = this->GetOffset();
		file_bin->Seek(0);

		while (!this->IsEnd() && !file_bin->IsEnd()) 
		{
			ch2 = file_bin->Getc();
			ch1 = this->Getc();
			if(ch1 != ch2)
			{
				file_bin->Seek(0);
				break;				
			}
		}

		if(file_bin->IsEnd())
		{
			return this->GetOffset() - file_bin->GetSize();
		}

		this->Seek(old + 1);
	}

	return -1;
}


int CFileBase::WriteToFile(CFileBase *file)
{
	return this->WriteToFile(file,0,this->GetSize());
}
long CFileBase::WriteToFile(CFileBase *file, long start, long wsize, void *buf, int buf_size)
{
	long bsize = buf_size;
	long sum = 0,ws,rs,need_read;

	ASSERT(file);
	
	this->Seek(start);

	while(sum < wsize)
	{
		need_read = bsize;

		if(need_read > wsize - sum)
			need_read = wsize - sum;
		rs = this->Read(buf,need_read);
		if(rs <= 0) break;

		ws = file->Write(buf,rs);
		if(ws <= 0) break;
		sum += ws;
	}
	
	return sum;
}
int CFileBase::FillBlock(long fill_size, char fill_ch)
{
	for(int i = 0; i<fill_size; i++)
	{
		this->Putc(fill_ch);
	}

	return OK;
}

int CFileBase::AdjustOffset()
{
	if(this->GetOffset() >= this->GetSize())
		this->Seek(this->GetSize());

	if(this->GetOffset() < 0)
		this->Seek(0);

	return OK;
}

int CFileBase::SeekEnd()
{
	return this->Seek(-1);
}

int CFileBase::Destroy()
{
	this->except_sp_chars = NULL;
	if(this->file_name)	
		FREE(this->file_name);

	return OK;
}
int CFileBase::SeekBack(long back_bytes)
{
	long off = this->GetOffset();

	off -= back_bytes;

	if(off < 0) off = 0;

	return this->Seek(off);
}

int CFileBase::ExpandFromOff(long exp_size)
{
	long b_size;
	
	b_size = this->GetSize();

	this->SetSize(this->GetOffset());
	
	this->AddBlock(exp_size);
	
	if(this->GetSize() < b_size)
		this->SetSize(b_size);

	return OK;
}
int CFileBase::Insert(CFileBase *file)
{
	long bsize = FILEBASE_LBUF_SIZE;
	char temp[FILEBASE_LBUF_SIZE];
	long old_size;
	long old_off,off;
	long sum = 0,need_read,rs,ws;

	ASSERT(file);

	old_size = this->GetSize();
	old_off = this->GetOffset();

	this->AddBlock(file->GetSize());
	sum = old_size - old_off;
	this->Seek(old_size);
	off = old_size;
	while(sum > 0)
	{
		need_read = bsize;
		if(need_read > sum)
			need_read = sum;
		off -= need_read;
		this->Seek(off);
		rs = this->Read(temp,need_read);
		if(rs <= 0) break;
		sum -= rs;
		this->Seek(off + file->GetSize());
		ws = this->Write(temp,rs);

		if(ws <= 0) break;
	}
	this->Seek(old_off);
	this->WriteFile(file);

	this->Seek(old_off + file->GetSize());

	return OK;
}

int CFileBase::Delete(long del_size)
{
	long sum,off,bsize=FILEBASE_LBUF_SIZE;
	char buf[FILEBASE_LBUF_SIZE];
	long need_read,rs;
	
	ASSERT(del_size > 0);

	off = this->GetOffset();
	
	if(this->GetSize() - off < del_size)
		del_size = this->GetSize() - off;
	
	if(del_size <= 0) return ERROR;

	sum = this->GetSize() - off - del_size;
	
	while(sum > 0)
	{
		need_read = bsize;

		if(need_read > sum)
			need_read = sum;		

		this->Seek(off + del_size);
		rs = this->Read(buf,need_read);
		if(rs <= 0) break;		
		this->Seek(off);
		this->Write(buf,rs);
		off += rs;
		sum -= rs;
	}	

	this->SetSize(this->GetSize() - del_size);

	return OK;
}


int CFileBase::IsEnd()
{
	if(this->GetOffset() >= this->GetSize())
		return TRUE;
		
	return FALSE;
}

long CFileBase::WriteFile(CFileBase *file, long start, long ws)
{
	char buf[FILEBASE_LBUF_SIZE];	
	return this->WriteFile(file,start,ws,buf,FILEBASE_LBUF_SIZE);
}

long CFileBase::WriteFile(CFileBase *file, long start, long ws, void *buf, int buf_size)
{
	long block_size = buf_size;
	long sum,rs,b_size,left,write_size;
	
	ASSERT(file);

	sum = 0;
	file->Seek(start);
	left = ws;

	while(left > 0)
	{
		b_size = left;
		if(b_size > block_size)
			b_size = block_size;
		rs = file->Read(buf,b_size);
		if(rs > 0)
		{
			write_size = this->Write(buf,rs);
			if(write_size > 0)
				left -= write_size;
			else
				break;
		}
		else
			break;
	}

	return ws - left;	
}

long CFileBase::WriteFile(CFileBase *file)
{
	ASSERT(file);
	return this->WriteFile(file,0,file->GetSize());
}
long CFileBase::WriteToFile(CFileBase *file,long wsize)
{
	return this->WriteToFile(file,0,wsize);
}

long CFileBase::WriteToFile(CFileBase *file,long start,long wsize)
{
	char buf[FILEBASE_LBUF_SIZE];	
	return this->WriteToFile(file,start,wsize,buf,FILEBASE_LBUF_SIZE);
}

int CFileBase::Printf(char *szFormat, ...)
{
    char szBuffer [FILEBASE_LBUF_SIZE];

    va_list pArgList ;
    va_start (pArgList, szFormat) ;
    vsprintf (szBuffer, szFormat, pArgList) ;
    va_end (pArgList) ;
    
	return this->Puts(szBuffer);
}

int CFileBase::ReadLine_Reverse()
{
	char ch;
	
	ch = this->UnPutc();
	if(ch != '\n')
		this->Putc(ch);

	while(1)
	{
		ch = this->UnPutc();
		if(this->GetOffset() <= 0)
			return OK;
		if(ch == '\n')
		{
			this->Putc(ch);
			break;
		}
	}

	return OK;
}

int CFileBase::ReadLine_Reverse(CFileBase *file)
{
	long off;
	int ret;

	this->ReadLine_Reverse();	
	off = this->GetOffset();
	ret = this->ReadLine(file);
	this->Seek(off);
	
	return ret;
}

int CFileBase::IsSpChar(char ch)
{
	char *p;
	if(ch == 0)
		return TRUE;
	if(this->except_sp_chars != NULL)
	{
		p = this->except_sp_chars;
		while(*p)
		{
			if(*p == ch)
				return FALSE;
			p++;
		}
	}
	p = this->sp_chars;
	while(*p)
	{
		if(*p == ch)
			return TRUE;
		p++;
	}
	return FALSE;
}

int CFileBase::SetDefaultSpChars()
{
	this->sp_chars = " \t\r\n!@#$%^=&*()|+-\\*/{}[];.\":\',?/<>~";
	return OK;
}
//the return value is the number of bytes it reads.
int CFileBase::ReadWordWithEmptyChar(CFileBase *file)
{
	int k = 0;
	char ch;
	
	ASSERT(file);

	file->SetSize(0);

	if(this->IsEnd())
		goto end;

	ch = this->Getc();
	if(ch == 0)
		goto end;
	
	if(this->IsSpChar(ch))
	{
		file->Putc(ch);
		k = 1;
		goto end;
	}
	while(!this->IsSpChar(ch))
	{
		file->Putc(ch);
		k++;
		if(this->IsEnd())
			break;
		ch = this->Getc();
	}
	if(this->IsSpChar(ch))
		this->UnGetc();
end:		
	file->Putc(0);
	return k;
}
int CFileBase::ReadString(CFileBase *file)
{
	int k;
	k = this->ReadWord(file);
	while(k)
	{
		file->Seek(0);
		if(!this->IsSpChar(file->Getc()))	
		{
			return OK;
		}
		k = this->ReadWord(file);
	}
	return ERROR;
}
int CFileBase::SkipEmptyChars()
{
	char ch;
	while(!this->IsEnd())
	{
		ch = this->Getc();
		if( ! this->IsEmptyChar(ch) )
		{
			this->UnGetc();
			break;
		}
	}
	return OK;
}
int CFileBase::ReadWord(CFileBase *file)
{
	this->SkipEmptyChars();
	return this->ReadWordWithEmptyChar(file);
}

int CFileBase::Puts(char *str)
{
	if(str == NULL)
		return ERROR;

	return this->Write(str,strlen(str));
}

int CFileBase::UnPutc()
{
	char ch=0;
	long off;

	off = this->GetOffset();

	if(off > 0)
	{
		off--;
		this->Seek(off);
		off = this->GetOffset();
		ch =  this->Getc();
		this->Seek(off);
	}

	return ch;
}
char CFileBase::UnGetc()
{
	return this->UnPutc();
}


int CFileBase::Dump()
{
	char buf[1024];
	long rs,i,save_off;
	
	save_off = this->GetOffset();
	this->Seek(0);

	while(1)
	{
		rs = this->Read(buf,1024);
		if(rs <=0 ) break;
		for(i=0;i<rs;i++)
		{
			if(buf[i] == 0)
				LOG(" ");
			else if(buf[i] != 7)
				LOG("%c",buf[i]);
		}
	}
	
	this->Seek(save_off);

	return OK;
}

int CFileBase::ReadLine(CFileBase *file)
{
	char ch;
	int ret;

	ASSERT(file);

	if(this->IsEnd()) 
		return ERROR;

	file->SetSize(0);
	
	ret = this->Read(&ch,1);
	if(ret <= 0)
		return ERROR;
	
	while(ch != '\n')
	{
		if(ch!='\r')
		{
			file->Putc(ch);
		}
		
		if(this->IsEnd())
			break;

		ret = this->Read(&ch,1);
		if(ret <= 0)
			return ERROR;
	}

	file->Putc(0);
	return OK;
}

int CFileBase::IsEmptyChar(char ch)
{
	if(		ch != ' ' 	&&	ch != '\0'
		&&	ch != '\r'	&&	ch != '\n'
		&&	ch != '\t')
		return FALSE;

	return TRUE;
}


int CFileBase::SetSplitChars(char *sp_str)
{
	if(sp_str)
		this->sp_chars = sp_str;
	return OK;
}


int CFileBase::SkipEmptyChars_Reverse()
{
	char ch;
	while(this->GetOffset() > 0)
	{
		ch = this->UnGetc();
		if( ! this->IsEmptyChar(ch) )
		{
			this->Getc();
			break;
		}
	}
	return OK;
}
//the return value is the number of bytes it reads.
int CFileBase::ReadWordWithEmptyChar_Reverse(CFileBase *file)
{
	int k = 0;
	char ch;
	
	ASSERT(file);

	file->SetSize(0);

	if(this->GetOffset() <= 0 )
		goto end;

	ch = this->UnGetc();
	if(ch == 0)
		goto end;
	
	if(this->IsSpChar(ch))
	{
		file->Putc(ch);
		k = 1;
		goto end;
	}
	while(!this->IsSpChar(ch))
	{
		file->Putc(ch);

		if(this->GetOffset() <= 0)
			break;
		k++;

		ch = this->UnGetc();
	}

	if(this->IsSpChar(ch))
		this->Getc();

end:		
	file->Reverse(0,file->GetOffset() - 1);
	file->Putc(0);

	return k;
}

int CFileBase::ReadWord_Reverse(CFileBase *file)
{
	this->SkipEmptyChars_Reverse();
	return this->ReadWordWithEmptyChar_Reverse(file);
}

char CFileBase::CharAt(long index)
{
	long old;
	char ch = 0;

	old = this->GetOffset();

	this->Seek(index);

	ch = this->Getc();

	this->Seek(old);

	return ch;
}

int CFileBase::SetChar(long index,char ch)
{
	long old;

	old = this->GetOffset();

	this->Seek(index);
	this->Putc(ch);

	this->Seek(old);

	return OK;
}
//start  end 0
// end - start  + 1
int CFileBase::Reverse(long start, long end)
{
	long i,t;
	char ch;
	
	t = end - start + 1;
	
	for(i = 0; i < t / 2; i++)
	{
		ch = this->CharAt(i + start);
		this->SetChar(i + start, this->CharAt(start + t - i -1 ));
		this->SetChar(start + t - i - 1, ch);
	}

	return OK;
}

int CFileBase::ReadString_Reverse(CFileBase *file)
{
	int k;
	k = this->ReadWord_Reverse(file);
	while(k)
	{
		file->Seek(0);
		if(!this->IsSpChar(file->Getc()))	
		{
			return OK;
		}
		k = this->ReadWord_Reverse(file);
	}
	return ERROR;
}

int CFileBase::Init()
{	
	this->SetDefaultSpChars();
#if _UNICODE_
	this->SetDefaultSpCharsW();
#endif

	this->except_sp_chars = NULL;
	this->file_name = NULL;

	return OK;
}

char CFileBase::GetLastChar(int empty_included)
{
	long old_off;
	char ch;

	old_off = this->GetOffset();
	this->Seek(this->GetSize() - 1);

	ch =  this->Getc();

	if(!empty_included)
	{
		while(CFileBase::IsEmptyChar(ch))
		{
			ch = this->UnGetc();
			if(this->GetOffset() <= 0)
				break;
		}
	}

	this->Seek(old_off);

	return ch;
}

int CFileBase::SetFileName(char *fn)
{
	if(this->file_name)
	{
		FREE(this->file_name);
	}

	MALLOC(this->file_name,char,strlen(fn) + 1);
	strcpy(this->file_name,fn);
	
	return OK;
}

//if the first char is special char, the word_only is ignored
int CFileBase::SearchStr(char *str, int case_sensive,int word_only)
{
	char *s2,ch1,ch2;
	int old,pos,len;
	int flag = 0;
	
	if(str == NULL)
		return -1;

	len = strlen(str);
	
	while(!this->IsEnd())
	{
		old = this->GetOffset();		
		ch1 = this->Getc();
		s2 = str;
		ch2 = *s2;
		if(!case_sensive)
		{
			ch1 = tolower(ch1);
			ch2 = tolower(ch2);
		}
		while (ch2 && !(ch1 - ch2)) 
		{
			s2 ++;
			ch2 = *s2;
			
			if(this->IsEnd())
			{flag = 1;break;}
			
			ch1=this->Getc();
			if(!case_sensive)
			{
				ch1 = tolower(ch1);
				ch2 = tolower(ch2);
			}
		}
		if(!*s2)
		{
			pos = this->GetOffset() - len - 1;
			if(flag) pos++; //if hit end
			
			if(!word_only)
			{
				return pos;
			}
			else if(IsSpChar(CharAt(pos)))
			{
				return pos;
			}
			else
			{
				if((pos == 0||IsSpChar(CharAt(pos - 1)))&&IsSpChar(CharAt(pos + len)))
					return pos;
			}

		}
		this->Seek(old + 1);
	}
	return -1;
}

int CFileBase::ReplaceStr(char *src_str, char *des_str, int case_sensive, int word_only,CFileBase *new_file)
{
	long pos,old_pos,len1;

	ASSERT(new_file);
	ASSERT(new_file != this);

	len1 = strlen(src_str);

	new_file->SetSize(0);
	
	old_pos = this->GetOffset();
	if(old_pos > 0)
	{
		this->WriteToFile(new_file,0,old_pos);
	}
	this->Seek(old_pos);

	while(!this->IsEnd())
	{
		pos = this->SearchStr(src_str,case_sensive,word_only);
		if(pos < 0)
		{
			this->WriteToFile(new_file,old_pos,this->GetSize() - old_pos);
			break;
		}
		else
		{
			this->WriteToFile(new_file,old_pos,pos - old_pos);
			new_file->Puts(des_str);
			old_pos = pos + len1;
			this->Seek(old_pos);
		}
	}
	return OK;
}

int CFileBase::ReadQuoteStr(char escape_char,char end_char,CFileBase *file)
{
	char ch;
	int ret;

	ASSERT(file);

	file->SetSize(0);

	while(!this->IsEnd())
	{
		ret = this->Read(&ch,1);
		if(ret <= 0)
			break;
		
		if(ch == escape_char) //escape char
		{
			file->Putc(ch);
			ret = this->Read(&ch,1);
				if(ret <= 0)
			break;

			file->Putc(ch);
		}
		else if(ch == end_char)
		{
			break;
		}
		else
		{
			file->Putc(ch);
		}
	}

	file->Putc(0);

	return OK;
}

int CFileBase::ReadCStr(CFileBase *file)
{
	return this->ReadQuoteStr('\\','\"',file);
}

int CFileBase::Getc_GB(char *letter)
{
	ASSERT(letter);
	
	char ch;
	int ret = 0;

	ch = this->Getc();

	if((BYTE)ch < 160)
	{
		letter[0] = ch;
		letter[1] = 0;
		ret = 1;
	}
	else
	{
		letter[0] = ch;
		letter[1] = this->Getc();
		ret = 2;
	}

	letter[2] = 0;

	return ret;
}

int CFileBase::InStrList(char *str, char *str_list, int case_sensive)
{
	int c;

	CMem mem,buf;
	
	LOCAL_MEM(buf);

	mem.Init();
	mem.SetP(str_list,strlen(str_list));
	mem.Seek(0);
	mem.SetSplitChars(",");
	while(mem.ReadWordWithEmptyChar(&buf))
	{
		if(buf.p[0] == ',')
			continue;
		if(case_sensive)
			c = buf.StrCmp(str) == 0;
		else
			c = buf.StrICmp(str) == 0;
		if(c)
			return TRUE;
	}
	return FALSE;
}
int CFileBase::SearchWordsList(char *words_list,int case_sensive)
{
	CMem mem,buf,buf1;
	int pos = -1,c,flag = 0;

	LOCAL_MEM(buf);
	LOCAL_MEM(buf1);

	mem.Init();

	mem.SetSplitChars(" \t");
	mem.SetP(words_list,strlen(words_list));

	while(!this->IsEnd())
	{
		mem.Seek(0);
		mem.ReadWord(&buf);
		pos = this->SearchStr(buf.p,case_sensive,TRUE);
		if(pos < 0) return -1;

		this->Seek(pos);
		this->ReadWord(&buf); //skip first word
		flag = 1;
		while(!mem.IsEnd())
		{
			mem.ReadWord(&buf);
			this->ReadWord(&buf1);
		
			c = case_sensive ? buf.StrCmp(buf1.p):buf.StrICmp(buf1.p);
			if(c != 0)
			{
				this->Seek(pos + 1);
				flag = 0;
				break;
			}
		}

		if(flag)
			return pos;
	}

	return -1;
}

int CFileBase::StrLen()
{
	int i,s =  this->GetSize();
	
	for(i = s-1; i >= 0; i--)
	{
		if(this->CharAt(i) ==0)
			s--;
		else
			break;
	}
	
	return s;
}

int CFileBase::StrCat(char *str)
{
	this->Seek(this->StrLen());
	this->Puts(str);
	this->Putc(0);

	return OK;
}

int CFileBase::StrCmp(char *str)
{
	CMem mem;
	mem.Init();
	mem.SetP(str,strlen(str) + 1);

	return this->StrCmp(&mem);
}

int CFileBase::StrCat(CFileBase *file)
{
	int len = this->StrLen();
	this->SetSize(len + 1);
	this->Seek(len);
	this->WriteFile(file);
	this->Putc(0);

	return OK;
}

int CFileBase::StrCmp(CFileBase *file)
{
	int ret = 0;
	unsigned char c1,c2;

	this->Seek(0);
	file->Seek(0);
	while(!file->IsEnd())
	{
		c1 = this->Getc();
		c2 = file->Getc();
		
		ret = c1 - c2;

		if(ret != 0)
			break;		
	}

	return ret;
}

int CFileBase::StrICmp(CFileBase *file)
{
	int ret = 0;
	unsigned char c1,c2;

	this->Seek(0);
	file->Seek(0);
	while(!file->IsEnd())
	{
		c1 = tolower(this->Getc());
		c2 = tolower(file->Getc());
		
		ret = c1 - c2;

		if(ret != 0)
			break;		
	}
	
	return ret;
}

int CFileBase::StrICmp(char *str)
{
	CMem mem;

	mem.Seek(0);
	mem.SetP(str,strlen(str)+1);

	return this->StrICmp(&mem);
}

int CFileBase::StrCpy(CFileBase *file)
{
	this->SetSize(0);
	this->WriteFile(file);
	this->Putc(0);

	return OK;
}

int CFileBase::StrCpy(char *str)
{
	CMem mem;

	mem.Seek(0);
	mem.SetP(str,strlen(str)+1);

	return this->StrCpy(&mem);
}

int CFileBase::StartWith(CFileBase *file_str, int case_sensive, int skip_empty)
{
	ASSERT(file_str);
	
	int i,len;
	unsigned char c1,c2;

	this->Seek(0);
	if(skip_empty)
		this->SkipEmptyChars();
	
	len = file_str->StrLen();

	if(this->GetSize() < len)
		return FALSE;

	file_str->Seek(0);

	for(i = 0; i < len; i++)
	{
		c1 = this->Getc();
		c2 = file_str->Getc();
		if( ! case_sensive)
		{
			c1 = tolower(c1);
			c2 = tolower(c2);
		}

		if(c1 != c2)
			return FALSE;		
	}

	return TRUE;
}

int CFileBase::StartWith(char *str, int case_sensive, int skip_empty)
{
	CMem mem;

	mem.Seek(0);
	mem.SetP(str,strlen(str)+1);
	
	return this->StartWith(&mem,case_sensive,skip_empty);
}
//
int CFileBase::StdStr()
{
	int i,l,n;
	
	l = this->StrLen();

	for(i = l - 1; i >= 0; i--)
	{
		if(!CFileBase::IsEmptyChar(this->CharAt(i)))
			break;
	}
	
	l = i + 1;
	for(i = 0; i < l; i++)
	{
		if(	! CFileBase::IsEmptyChar(this->CharAt(i)) )
			break;
	}
	l -= i;
	n = i;
	for(i = 0; i < l; i++)
	{
		this->SetChar(i,this->CharAt(i+n));
	}

	this->SetChar(l,0);
	this->SetSize(l + 1);

	return OK;
}
//read left to file, from current offset
int CFileBase::ReadLeftStr(CFileBase *file,int skip_empty)
{
	int ret = 0;

	file->SetSize(0);
	if(skip_empty)
		this->SkipEmptyChars();
	ret = this->WriteToFile(file,this->GetOffset(),this->GetSize() - this->GetOffset());
	file->Putc(0);

	return ret;
}

int CFileBase::Puts(CFileBase *file_str)
{
	ASSERT(file_str);
	int len = file_str->StrLen();
	return this->WriteFile(file_str,0,len);
}
int CFileBase::ReadLine(int line_index,CFileBase *file)
{
	ASSERT(file);
	
	int i = 0;

	this->Seek(0);
	while(this->ReadLine(file))
	{
		if(i == line_index)
		{
			return OK;
		}
		i++;	
	}

	file->SetSize(0);
	file->Putc(0);

	return ERROR;
}

int CFileBase::Split(CFileBase *file)
{
	ASSERT(file);

	char ch;
	int lines = 0;

	file->SetSize(0);
	this->Seek(0);
	while(!this->IsEnd())
	{
		ch = this->Getc();
		if(this->IsSpChar(ch))
		{
			file->Putc('\n');
			lines ++;
		}
		else
		{
			file->Putc(ch);
		}
	}

	file->Putc(0);

	return lines;
}
]]>
</file>
<file name="mem.h">
<![CDATA[
#ifndef __CMEM_H
#define __CMEM_H

#include "common.h"
#include "filebase.h"

#define LOCAL_MEM(name) char __##name[LBUF_SIZE];\
name.Init();\
name.SetP(__##name,LBUF_SIZE);\
name.SetSize(0)\

#define LOCAL_MEM_WITH_SIZE(name,size) char __##name[size];\
name.Init();\
name.SetP(__##name,size);\
name.SetSize(0)\

class CMem:public CFileBase{
public:
    char *p;
    long size; //size is changable
    long offset;
	BOOL self_alloc;
	long max_size; 
public:
	int SetP(char *p);
	int Copy(CMem *mem);
	long GetMaxSize();
	int SetStr(char *str);
	int SizeToMax();
	int AddBlock(long bsize);
	long GetSize();
	long GetOffset();
	CMem();
	~CMem();
	int Destroy();
	long Malloc(long asize);
	long Read(void *buf,long n);
	int Zero();	
	int Init();
	int Print();
	int SetP(char *p,long s);
	int Seek(long off);
	int SetSize(long ssize);
	long Write(void *buf,long n);

};

#endif

]]>
</file>
<file name="mem.cpp">
<![CDATA[
#include "stdafx.h"
#include "mem.h"

CMem::CMem()
{
	this->Init();
}
CMem::~CMem()
{
	this->Destroy();
}

int CMem::Destroy()
{
	if(p == NULL)
		return ERROR;

	if(this->self_alloc)
    {
		DEL_ARRAY(this->p);
	}

	this->p = NULL;
	this->self_alloc = FALSE;
    this->size = 0;
	this->max_size = 0;
    this->offset = 0;

	CFileBase::Destroy();

	return OK;
}
long CMem::Malloc(long asize)
{
    if(asize <= 0)
        return 0;

    if(this->p != NULL)
        return 0;

	NEW_ARRAY(this->p,char,asize);

	this->self_alloc = TRUE;
    this->size = 0;
    this->offset = 0;
	this->max_size = asize;

    return asize;
}
long CMem::Read(void *buf,long n)
{
    long  copy_length;
    
    ASSERT(this->p);

    if(this->size - this->offset > n)
        copy_length=n;
    else
        copy_length=this->size - this->offset;
	
	if(copy_length > 0)
	{
		memcpy(buf,(this->p+this->offset),copy_length);
	    this->offset += copy_length; 
		return copy_length;
	}

	return 0;
}
long CMem::Write(void *buf,long n)
{
    long  copy_length;
	
	ASSERT(this->p);
	
	if(n + this->offset > this->size)
	{
		this->AddBlock(n + this->offset - this->size);
	}
	
    if(this->size - this->offset > n)
        copy_length=n;
    else
        copy_length=this->size - this->offset;

	if(copy_length > 0)
	{
		memcpy((this->p+this->offset),buf,copy_length);
		this->offset += copy_length; 
		return copy_length;  
	}
    
	return 0;
}
int CMem::Zero()
{
	ASSERT(this->p);

    memset(this->p,0,this->max_size);

    this->offset = 0;
	this->size = 0;

	return OK;
}
int CMem::Init()
{
	CFileBase::Init();
    this->p = NULL;
    this->size = 0;
    this->offset = 0;
	this->self_alloc = FALSE;
	this->max_size = 0;

	return OK;
}

int CMem::Print()
{
    LOG("\np = 0x%x\n",this->p);
    LOG("size = %ld\n",this->size);
	LOG("max_size = %ld\n",this->max_size);
    LOG("offset = %ld\n",this->offset);

	return OK;
}

int CMem::SetP(char *p,long s)
{
	
	ASSERT(this->p == NULL);

	this->p = p;
	this->size = s;
	this->max_size = s;

	return OK;
}
int CMem::Seek(long off)
{
	if(off < 0 || off >= this->size)
		this->offset = this->size;
	else
		this->offset = off;
	
	return OK;
}
long CMem::GetOffset()
{
	return this->offset;
}

long CMem::GetSize()
{
	return this->size;
}
int CMem::SetSize(long ssize)
{
	if(ssize >= 0 && ssize <= this->max_size)
	{
		this->size = ssize;
		this->AdjustOffset();
		return OK;
	}

	return ERROR;
}

int CMem::AddBlock(long bsize)
{
	//
	//
	if(this->p == NULL)
	{
		this->Malloc(bsize);
		return OK;
	}

	this->size += bsize;

	if(this->size < 0)
		this->size = 0;

	if(this->size > this->max_size)
		this->size = this->max_size;

	return OK;
}

int CMem::SizeToMax()
{
	this->size = this->GetMaxSize();
	return OK;
}

int CMem::SetStr(char *str)
{
	ASSERT(str);

	CMem mem;
	mem.Init();
	mem.SetP(str,strlen(str) + 1);

	this->Copy(&mem);

	return OK;
}

long CMem::GetMaxSize()
{
	return this->max_size;
}

int CMem::Copy(CMem *mem)
{
	if(this == mem)
		return OK;

	if(this->GetMaxSize() < mem->GetSize())
	{
		this->Destroy();
		this->Init();
		this->Malloc(mem->GetSize());
	}

	this->SetSize(0);
	this->WriteFile(mem);

	return OK;
}

int CMem::SetP(char *p)
{
	ASSERT(p);
	return this->SetP(p,strlen(p)+1);
}
]]>
</file>

<file name="memfile.h">
<![CDATA[
#ifndef __CMEMFILE_H
#define __CMEMFILE_H

#include "common.h"
#include "filebase.h"

class CMemFile:public CFileBase{    
public:
	long size;
	long pages;
    long offset;
    int max_page;  
    char **base;
	long pagesize;
	DWORD mod_n;
	DWORD shift_n;
public:
	long GetMaxSize();
	int InitShift();
	long GetSize();
	long GetOffset();
	int SetSize(long s);
	CMemFile();
	~CMemFile();
	int Init(long page_size,long max_page);
	int Init();
	int Destroy();
	int Close();
	int SetMaxPages(long mp);
	int AddPage();
	int Open(long s);
	int AddBlock(long block_size);
	long Read(void *buf,long rsize);
	long Write(void *buf,long wsize);
	int Print();
	int Seek(long off);
};

#endif

]]>
</file>

<file name="memfile.cpp">
<![CDATA[
#include "memfile.h"

CMemFile::CMemFile()
{
	this->size = 0;
	this->base = NULL;
	this->max_page = 0;
	this->offset = 0;
	this->pages = 0;
	this->pagesize = 64*1024;
	this->mod_n = 0xffffffff;
	this->shift_n = 0;
}
CMemFile::~CMemFile()
{
	this->Destroy();
}
int CMemFile::Init()
{   
	CFileBase::Init();

	this->size = 0;
	this->base = NULL;
	this->max_page = 0;
	this->offset = 0;
	this->pages = 0;
	this->pagesize = 64*1024;
	this->InitShift();
	this->SetMaxPages(1024);

	return OK;
}
int CMemFile::Init(long page_size,long max_pages)
{
	if(max_pages < 0)
		return ERROR;
	
	CFileBase::Init();
	
	this->size = 0;
	this->base = NULL;
	this->max_page = 0;
	this->offset = 0;
	this->pages = 0;
	this->pagesize = page_size;
	this->SetMaxPages(max_pages);
	this->InitShift();

	return OK;
}
int CMemFile::InitShift()
{
	int i;

	for(i = 5; i < 32; i++)
	{
		if( (1 << i) == this->pagesize)
		{
			this->shift_n = i;
			this->mod_n = this->pagesize - 1;

			return OK;
		}
	}
	
	LOG("error pagesize, this value must can be gotten by 1<<n\n");
	LOG("and must greater than 32\n");
	
	return ERROR;
}

int CMemFile::Destroy()
{
	this->Close();
	if(this->base)
	{
		FREE(this->base);
		this->base = NULL;
	}
	this->size = 0;
	this->offset = 0;
	this->pages = 0;
	this->max_page = 0;

	return OK;
}
int CMemFile::Close()
{
	long i;
	
	for(i=0;i<this->pages;i++)
	{
		if(this->base[i] != NULL)
		{
			FREE(this->base[i]);
			this->base[i] = NULL;
		}
	}
	this->size = 0;
	this->offset = 0;
	this->pages = 0;
	return OK;
}
int CMemFile::SetMaxPages(long mp)
{
	if(mp <= 0)
		return ERROR;
	
	this->max_page = mp;
	return OK;
}
int CMemFile::AddPage()
{
	long i;
	
	if(this->base == NULL)
	{
		if(this->base != NULL)
			FREE(this->base);
		MALLOC(this->base,char *,this->max_page);
		if(this->base == NULL)
			return ERROR;
		
		for(i=0;i<this->max_page;i++)
			this->base[i] = NULL;
	}
	
	if(this->pages >= this->max_page)
	{
		LOG("Too many pages!");
		return ERROR;
	}
	
	MALLOC(this->base[this->pages] ,char, this->pagesize);
	if(this->base[this->pages] == NULL)
	{
		LOG("Memory alloc failure!");
		return ERROR;
	}
	this->pages ++;
	return OK;
}
int CMemFile::Open(long s)
{
	long i,p;
	
	if(this->base == NULL)
		return ERROR;
	if(this->pages > 0)
		return ERROR;
	p = (s >> this->shift_n) +1;
	this->size = s;
	this->offset = 0;
	for(i=0; i < p ;i++)
	{
		this->AddPage();
	}
	return OK;
}
int CMemFile::AddBlock(long block_size)
{
	long i,pn,new_page;
	
	new_page = ((this->size+block_size) >> this->shift_n) + 1; 
	pn=new_page - this->pages;
	if(new_page > this->pages)
	{
		for(i = 0; i < pn; i++)
			this->AddPage();
	}
	this->size += block_size;  
	
	return OK;
}
long CMemFile::Read(void *buf,long rsize)
{
	long left,sum=0,read_size=0;
	long block_end;
	long block=this->offset >> this->shift_n;
	long off=this->offset & this->mod_n;

	if(this->offset + rsize > this->size)
		rsize=this->size - this->offset;

	left = rsize;
	while(sum<rsize)
	{
		block_end = (block << this->shift_n) + this->pagesize;
		if(this->offset + left < block_end)
		{
			read_size=left;
		}
		else
		{
			read_size = block_end - this->offset;
		}
		memcpy((char*)buf+sum , this->base[block] + off, read_size);
		this->offset += read_size;
		sum += read_size;
		left -= read_size;
		block = this->offset >> this->shift_n;
		off = this->offset & this->mod_n;
	}
	return sum;
}
long CMemFile::Write(void *buf,long wsize)
{
	long sum=0, write_size=0;
	long block_end;
	long left=wsize;
	long block= this->offset >> this->shift_n;
	long off=this->offset & this->mod_n;
	
	if(wsize <= 0) return 0;
	
	if(wsize + this->offset > this->size)
	{
		this->AddBlock(wsize + this->offset - this->size);
	}
	
	while(sum<wsize)
	{
		block_end = (block << this->shift_n) + this->pagesize;
		if(this->offset + left < block_end)
		{
			write_size=left;
		}
		else
		{
			write_size=block_end - this->offset;
		}
		memcpy(this->base[block]+off,(char*)buf+sum,write_size);
		this->offset += write_size;
		sum += write_size;
		left -= write_size;
		block = this->offset >> this->shift_n;
		off = this->offset & this->mod_n;
	}
	return sum;
}

int CMemFile::Print()
{
	LOG("\nsize = %ld\n",this->size);
	LOG("pages = %ld\n",this->pages);
	LOG("max_page = %ld\n",this->max_page);
	LOG("offset = %ld\n",this->offset);

	return OK;
}

int CMemFile::Seek(long off)
{
	if(off < 0 || off >= this->size)
		this->offset = this->size;
	else
		this->offset = off;

	return OK;
}

int CMemFile::SetSize(long s)
{
	if(s < 0) return ERROR;
	
	if(s > this->pages * this->pagesize)
		return ERROR;
	
	this->size = s;
	
	this->AdjustOffset();

	return OK;
}

long CMemFile::GetOffset()
{
	return this->offset;
}

long CMemFile::GetSize()
{
	return this->size;
}

long CMemFile::GetMaxSize()
{
	return this->max_page * this->pagesize;
}

]]>
</file>

<file name="memstk.h">
<![CDATA[
// MemStk.h: interface for the CMemStk class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MEMSTK_H__C52A5CBF_0474_4D45_8034_A015FDCFF513__INCLUDED_)
#define AFX_MEMSTK_H__C52A5CBF_0474_4D45_8034_A015FDCFF513__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "mem.h"

class CMemStk{
public:
    CMem **index;
    long top;
	long size;
	BOOL case_sensitive;
public:
	int SetCaseSensetive(BOOL c);
	int CompMem(CMem *mem1,CMem *mem2);
	int Push(char *str);
	long BSearch_Pos(CMem *node,int order,int *find_flag);
	int InsOrdered(CMem *str,int order,int unique);
	int DelElem(long i);
	int InsertElem(long i,CMem *node);
	long BSearch(CMem *node,int order);
	CMem * BSearch_Node(CMem *node,int order);
	int Sort(int order);
	CMem * GetElem(long index);
	CMem * GetTop();
	CMem * Search(CMem *node);
	CMem *PushEmpty();
	CMemStk();
	int Clear();
	int DelTop();
	int Destroy();
	int Init(long init_size);
	int IsEmpty();
	int IsFull();
	int Pop(CMem *node);
	int Print();
	int Push(CMem *node);
	long GetLen();
	~CMemStk();
};


#endif // !defined(AFX_MEMSTK_H__C52A5CBF_0474_4D45_8034_A015FDCFF513__INCLUDED_)

]]>
</file>

<file name="memstk.cpp">
<![CDATA[
// MemStk.cpp: implementation of the CMemStk class.
//
//////////////////////////////////////////////////////////////////////
#include "MemStk.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CMemStk::CMemStk()
{
	this->index = NULL;
	this->top = 0;
	this->case_sensitive = TRUE;
}

CMemStk::~CMemStk()
{
    this->Destroy();
}

int CMemStk::Init(long init_size)
{
    int i;

    this->top = 0;
	this->size = init_size;

	MALLOC(this->index,CMem * ,this->size);
    
	for(i = 0; i < this->size; i++)
        this->index[i] = NULL;
    
	return OK;
}

int CMemStk::Destroy()
{
    int i;
	
	if(this->index == NULL)
		return ERROR;

    for(i = 0; i < this->size; i++)
    {
		if(this->index[i])
		{
			this->index[i]->Destroy();
			DEL(this->index[i]);
		}
	}

    FREE(this->index);

    this->index=NULL;
    this->top=0;
    this->size=0;
    
	return OK;
}

int CMemStk::IsEmpty()
{
    if(this->top <= 0)
        return TRUE;
    else
        return FALSE;
}

int CMemStk::IsFull()
{
	if(this->top >= this->size)
		return TRUE;

	return FALSE;
}

int CMemStk::Push(CMem *node)
{
    CMem *p;

    p = this->PushEmpty();

    if(p == NULL)
		return ERROR;

    p->Copy(node);

    return OK;
}

int CMemStk::Pop(CMem *node)
{
    if(this->IsEmpty())
		return ERROR;

    this->top--;

    node->Copy(this->index[this->top]);
    
	this->index[this->top]->Destroy();

	DEL(this->index[this->top]);
    
	return OK;
}

int CMemStk::Print()
{
    int i;

    for(i = 0; i <this->top; i++)
    {
        LOG("%s\n",this->index[i]->p);
    }

    LOG("\n");
    LOG("size=%ld\n",this->size);
    LOG("top=%ld\n",this->top);
    LOG("bottom=%ld\n",0);

    return OK;
}

long CMemStk::GetLen()
{
    return this->top;
}

CMem * CMemStk::Search(CMem *node)
{
    int i;
    
	for(i=0;i<this->top;i++)
    {
        if(this->CompMem(index[i],node)==0)
            return this->index[i];
    }

    return NULL;
}

CMem * CMemStk::GetTop()
{
    if(this->IsEmpty())
        return NULL;

    return this->index[this->top - 1];
}

int CMemStk::DelTop()
{
    if(this->IsEmpty())
        return ERROR;

    this->top--;

    this->index[this->top]->Destroy();
	
	DEL(this->index[this->top]);

    return OK;
}

int CMemStk::Clear()
{
    while(this->DelTop());
    return OK;
}
CMem *CMemStk::PushEmpty()
{
	if(this->IsFull())
	{
		REALLOC(this->index,CMem *,this->size,this->size * 2);

		this->size *= 2;

		for(int i = this->top; i < this->size; i++)
		{
			this->index[i] = 0;
		}
	}
	
	NEW(this->index[this->top] , CMem );
	this->index[this->top]->Init();
  
	this->top++;
    
    return this->index[this->top - 1];
}

CMem * CMemStk::GetElem(long index)
{
	if(index < 0 || index >= this->top)
		return NULL;

	return this->index[index];
}

int CMemStk::Sort(int order)
{

    long i,j,c;    

	CMem *pt;

    for(j=this->GetLen(); j > 0; j--)
    {
        for(i = 0; i < j - 1; i++)
        {
            if(order==0)
				c = this->CompMem(index[i],index[i+1]) > 0;
            else
				c = this->CompMem(index[i],index[i+1]) < 0;
            if(c)
            {
                
                pt = index[i];
				index[i] = index[i + 1];
				index[i + 1] = pt;                
            }
        }
    }
  
    return OK;
}

CMem * CMemStk::BSearch_Node(CMem *node,int order)
{
	long i;

	i = this->BSearch(node,order);

	return this->GetElem(i);
}

long CMemStk::BSearch(CMem *node,int order)
{
	int find,pos;

	pos = this->BSearch_Pos(node,order,&find);

	if(find) return pos;

	return -1;
}
int CMemStk::InsertElem(long i, CMem *node)
{
	//insert a node at pos i
	CMem *new_node;

	ASSERT(i >= 0 && i <= this->top);
	
	//Add a new node
	new_node = this->PushEmpty(); 
	ASSERT(new_node);
	//copy value
	new_node->Copy(node);

	for(int k = this->top - 1; k >= i; k--)
	{
		this->index[k] = this->index[k - 1];
	}

	this->index[i] = new_node;
	
	return OK;
}
int CMemStk::DelElem(long i)
{
	CMem *p;
	
	ASSERT(i >= 0 && i < this->top);

	p = this->GetElem(i);

	DEL(p);

	for(int k = i; k < this->top; k++)
	{
		this->index[k] = this->index[k + 1];
	}
	
	this->top --;

	this->index[top] = NULL;

	return OK;
}

int CMemStk::InsOrdered(CMem *node, int order,int unique)
{
	int pos,find;

	pos = this->BSearch_Pos(node,order,&find);

	if(find && unique)
		return ERROR;

	return this->InsertElem(pos,node);
}

long CMemStk::BSearch_Pos(CMem *node, int order, int *find_flag)
{
	long low,high,mid,c;
	long flag = 0,pos = -1;

	ASSERT(order == 0 || order == 1);

    low = 0; high=this->GetLen() - 1;

    while(low<=high)
    {
        mid = (low+high) >> 1;
        
		if(this->CompMem(node,index[mid]) == 0)
		{
			*find_flag = TRUE;
			return mid;
		}

        if(order == 0)
            c = this->CompMem(index[mid],node) > 0;
        else
            c = this->CompMem(index[mid],node) < 0;
        if(c)
            high = mid-1;
        else
            low = mid+1;
    }
	
	*find_flag = FALSE;

	return low;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int CMemStk::Push(char *str)
{
	CMem *p;

	p = this->PushEmpty();

	ASSERT(p);

	p->SetStr(str);

	return OK;
}

int CMemStk::CompMem(CMem *mem1, CMem *mem2)
{
	if(this->case_sensitive)
		return mem1->StrCmp(mem2->p);
	else
		return mem1->StrICmp(mem2->p);
}

int CMemStk::SetCaseSensetive(BOOL c)
{
	this->case_sensitive = (c != 0);

	return OK;
}

]]>
</file>

<file name="text.h">
<![CDATA[
#include "mem.h"
#include "stdlib.h"
#include "filebase.h"
#include "memfile.h"

int is_split_line(char *line);
int PrintFile(CFileBase *file);
int get_single_name(char *fn,char *single);
int get_ext(char *name,char *ext);
int get_path(char *full,char *path);
int get_file_name(char *fullname,char *filename);
int ToCStr(CFileBase *in, CFileBase *out);
int RepFile(CFileBase *file,char *src,char *des,int case_sensive,int word_only);

]]>
</file>

<file name="text.cpp">
<![CDATA[
#include "text.h"
#include "mem.h"

int is_split_line(char *line)
{
	int l = strlen(line);
	
	if(l <= 0) return FALSE;
	for(int i = 0; i < l; i++)
	{
		if(line[i] != '-')
			return FALSE;			
	}
	
	return TRUE;
}

int PrintFile(CFileBase *file)
{
	ASSERT(file);
	CMem mem;
	
	LOCAL_MEM(mem);
	
	file->Seek(0);
	while(file->ReadLine(&mem))
	{
		puts(mem.p);
		puts("\r\n");
	}
	return OK;
}

int get_path(char *full,char *path)
{
    int i,l;
    int flag;
    char ch;
    
    path[0] = 0;
    flag = 0;
    
    l = strlen(full);
    
    for(i=l-1;i>=0;i--)
    {
        if(full[i]=='/'||full[i]=='\\')
        {
            flag=1;
            break;
        }
    }
    if(flag)
    {
        memcpy(path,full,i);
        path[i] = 0;
    }
    return OK;
}

int get_ext(char *name,char *ext)
{
    int i,l;
    int flag;
    
    flag = 0;
    
    l = strlen(name);
    
    for(i=l-1;i>=0;i--)
    {
        if(name[i]=='.')
        {
            flag=1;
            break;
        }
    }

    if(flag)
        strcpy(ext,name+i+1);
    else
        ext[0]=0;
    return OK;
}
int get_single_name(char *fn,char *single)
{
	int k,i,pos,s,len;
	
	len  = strlen(fn);
	s = 0;
	pos = len;
	
	for(i=len - 1; i>=0; i--)
	{
		if(fn[i] =='.')
		{
			pos = i;
			break;
		}
	}
	
	for(i=len - 1; i>=0; i--)
	{
		if(fn[i] =='/' || fn[i] == '\\')
		{
			s = i + 1;
			break;
		}
	}

	k = 0;
	for(i = s; i < pos; i++)
	{
		single[k++] = fn[i];
	}
	single[k] = 0;
	
	return OK;
}
int get_file_name(char *fullname,char *filename)
{
  int len;
  
  get_single_name(fullname,filename);
  len = strlen(filename);
  get_ext(fullname,filename+len+1);
  if(filename[len+1] != 0)
  {
  	filename[len] = '.';
  }
  
  return OK;
}
int ToCStr(CFileBase *in, CFileBase *out)
{
	ASSERT(in && out);
	
	char ch;

	in->Seek(0);
	out->SetSize(0);
	out->Putc('\"');
	
	while(!in->IsEnd())
	{
		ch = in->Getc();
		if(ch == 0)
			break;

		if(strchr("\"\'\\",ch))
		{
			out->Putc('\\');
			out->Putc(ch);
		}
		else if(ch == '\r')
			out->Puts("\\r");
		else if(ch == '\n')
			out->Puts("\\n\"\r\n\"");
		else if(ch == '\t')
			out->Puts("\\t");
		else 
			out->Putc(ch);		
	}

	out->Putc('\"');	
	out->Putc(0);

	return OK;
}

int RepFile(CFileBase *file,char *src,char *des,int case_sensive,int word_only)
{
	CMemFile mf;
	mf.Init();
	
	file->Seek(0);
	file->ReplaceStr(src,des,case_sensive,word_only,&mf);
	
	file->SetSize(0);
	file->WriteFile(&mf);
	
	return OK;
}
]]>
</file>
</File>
<Graphics>



<file name="graphics.h">
<![CDATA[
#ifndef __GRAPHICS_H
#define __GRAPHICS_H

#include "common.h"
#include "rect.h"

/* Brush Styles */
#define BS_SOLID            0
#define BS_NULL             1
#define BS_HOLLOW           BS_NULL
#define BS_HATCHED          2
#define BS_PATTERN          3
#define BS_INDEXED          4
#define BS_DIBPATTERN       5
#define BS_DIBPATTERNPT     6
#define BS_PATTERN8X8       7
#define BS_DIBPATTERN8X8    8
#define BS_MONOPATTERN      9

/* Hatch Styles */
#define HS_HORIZONTAL       0       /* ----- */
#define HS_VERTICAL         1       /* ||||| */
#define HS_FDIAGONAL        2       /* \\\\\ */
#define HS_BDIAGONAL        3       /* ///// */
#define HS_CROSS            4       /* +++++ */
#define HS_DIAGCROSS        5       /* xxxxx */

/* Pen Styles */
#define PS_SOLID            0
#define PS_DASH             1       /* -------  */
#define PS_DOT              2       /* .......  */
#define PS_DASHDOT          3       /* _._._._  */
#define PS_DASHDOTDOT       4       /* _.._.._  */
#define PS_NULL             5
#define PS_INSIDEFRAME      6
#define PS_USERSTYLE        7
#define PS_ALTERNATE        8

/*
*DrawText() Format Flags 
*/
#define DT_TOP              0x00000000
#define DT_LEFT             0x00000000
#define DT_CENTER           0x00000001
#define DT_RIGHT            0x00000002
#define DT_VCENTER          0x00000004
#define DT_BOTTOM           0x00000008
#define DT_WORDBREAK        0x00000010
#define DT_SINGLELINE       0x00000020
#define DT_EXPANDTABS       0x00000040
#define DT_TABSTOP          0x00000080
#define DT_NOCLIP           0x00000100
#define DT_EXTERNALLEADING  0x00000200
#define DT_CALCRECT         0x00000400
#define DT_NOPREFIX         0x00000800
#define DT_INTERNAL         0x00001000

#define DIB_RGB_COLORS      0 /* color table in RGBs */
#define DIB_PAL_COLORS      1 /* color table in palette indices */

#define GetRValue(rgb)      ((BYTE)(rgb))
#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)      ((BYTE)((rgb)>>16))

#define OEM_FIXED_FONT      10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT       12
#define SYSTEM_FONT         13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16
#define DEFAULT_GUI_FONT    17

#define TRANSPARENT         1
#define OPAQUE              2

#define RGB(r,g,b)          ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)))

#define FRAME3D_UP          1
#define FRAME3D_DOWN        2

#define TRI_UP              1
#define TRI_DOWN            2
#define TRI_LEFT            3
#define TRI_RIGHT           4

typedef DWORD   COLORREF;

#define LF_FACESIZE         32

typedef struct tagLOGFONTA
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    CHAR      lfFaceName[LF_FACESIZE];
}LOGFONT;

#ifdef __cplusplus
extern "C" {
#endif

int line(int left,int top,int right,int bottom);
int get_rect(int i,int *l,int *t,int *r,int *b);
int set_pen(int style,int width,COLORREF color);
int set_rect(int i,int l,int t,int r,int b);
int set_brush(int style,COLORREF color,int hatch);
int fill_rect(int l,int t,int w,int h);
int draw_text(char *str,int size,RECT *rect,DWORD format);
int ellipse(int l,int t,int w,int h);
int set_stock_font(int stock_font);
int set_text_color(COLORREF color);
int set_bk_mode(int mode);
int set_pixel(int x,int y,COLORREF c);
int set_bk_color(COLORREF c);
int arc(int nLeftRect,int nTopRect,int nRightRect,int nBottomRect,
				int nXRadial1,int nYRadial1,int nXRadial2,int nYRadial2);
int set_font(LOGFONT *lf);

#ifdef __cplusplus
} //extern "C"
#endif

#define SetPixel set_pixel
#define DrawLine line
#define SetPen set_pen
#define SetBrush set_brush
#define SetStockFont set_stock_font
#define SetBkMode set_bk_mode
#define SetBkColor set_bk_color
#define SetTextColor set_text_color
#define Arc arc
#define SetFont set_font

int FillRect(CRect *r);
int SetRect(CRect *r);
int GetRect(CRect *r);
int DrawRect(CRect *r);
int DrawText(char *str,CRect *rect,DWORD format);
int Ellipse(CRect *r);
int SetSolidBrush(COLORREF color);
int SetHatchBrush(int style,COLORREF color);
int Draw3DFrame(int up_or_down,CRect *rect);
int Draw3DHLine(int x1,int x2,int y);
int Draw3DVLine(int x,int y1,int y2);
int DrawSmallTriangle(int x,int y,int dir,int triw,COLORREF color);
int Draw3DBorder(CRect *r);
int DrawDefRect(CRect *rect,char *txt);
int DrawCircle(CRect *r);
int TextOut(int x,int y,char *str);

#endif

]]>
</file>
<file name="graphics.cpp">
<![CDATA[
#include "graphics.h"

int GetRect(CRect *r)
{
  int i = get_self_num();
	return get_rect(i,&r->left,&r->top,&r->right,&r->bottom);	
}

int SetRect(CRect *r)
{
  int i = get_self_num();
	return set_rect(i,r->left,r->top,r->right,r->bottom);	
}

int FillRect(CRect *r)
{
    return fill_rect(r->left,r->top,r->GetWidth(),r->GetHeight());
}

int DrawRect(CRect *r)
{
	line(r->left,r->top,r->right,r->top);
	line(r->left,r->top,r->left,r->bottom);
	line(r->right,r->top,r->right,r->bottom);
	line(r->left,r->bottom,r->right+1,r->bottom);

	return OK;
}
int DrawText(char *str,CRect *rect,DWORD format)
{
	RECT r;
	
	r.left = rect->left;
	r.top = rect->top;
	r.right = rect->right;
	r.bottom = rect->bottom;
	
	draw_text(str,strlen(str),&r,format);
	
	return OK;
}
int TextOut(int x,int y,char *str)
{
	RECT r;
	
	r.left = x;
	r.top = y;
	r.right = x + 10000;
	r.bottom = y + 10000;
	
	draw_text(str,strlen(str),&r,DT_LEFT);
	
	return OK;
}
int Ellipse(CRect *r)
{
	CRect rt;
	
	rt.Copy(r);
	
	rt.Normalize();

	ellipse(rt.left,rt.top,rt.right,rt.bottom);
	
	return OK;
}

int DrawCircle(CRect *r)
{
	return Arc(r->left,r->top,r->right,r->bottom,r->left,r->top,r->left,r->top);
}

int SetSolidBrush(COLORREF color)
{
  return SetBrush(BS_SOLID,color,0);
}
int SetHatchBrush(int style,COLORREF color)
{
	return SetBrush(BS_HATCHED,color,style);
}

int Draw3DFrame(int up_or_down,CRect *rect)
{
	
	CRect r;
	
	r.Copy(rect);
	r.Normalize();
	SetSolidBrush(RGB(192,192,192));
	FillRect(&r);
	
	SetPen(PS_SOLID,0,RGB(128,128,128));
	DrawLine(r.left,r.top,r.left,r.bottom+1);
	DrawLine(r.left,r.top,r.right,r.top);
	
	if(up_or_down == FRAME3D_UP)
		SetPen(PS_SOLID,0,RGB(255,255,255));
	else
		SetPen(PS_SOLID,0,RGB(0,0,0));
		
	DrawLine(r.left+1,r.top+1,r.left+1,r.bottom);
	DrawLine(r.left+1,r.top+1,r.right,r.top+1);
	
	SetPen(PS_SOLID,0,RGB(128,128,128));
	DrawLine(r.right-1,r.top,r.right-1,r.bottom);
  DrawLine(r.right,r.bottom-1,r.left,r.bottom-1);
  if(up_or_down == FRAME3D_UP)
		SetPen(PS_SOLID,0,RGB(0,0,0));
	else
		SetPen(PS_SOLID,0,RGB(255,255,255));
	DrawLine(r.right,r.top,r.right,r.bottom);
  DrawLine(r.right,r.bottom,r.left,r.bottom);
	  
  return OK;
}  

int Draw3DHLine(int x1,int x2,int y)
{
	SetPen(PS_SOLID,0,RGB(255,255,255));	
	DrawLine(x1,y+1,x2,y+1);
	SetPen(PS_SOLID,0,RGB(128,128,128));	
	DrawLine(x1,y,x2,y);
	return OK;
}
int Draw3DVLine(int x,int y1,int y2)
{
	SetPen(PS_SOLID,0,RGB(255,255,255));	
	DrawLine(x+1,y1,x+1,y2);
	SetPen(PS_SOLID,0,RGB(128,128,128));	
	DrawLine(x,y1,x,y2);
	return OK;
}
int DrawSmallTriangle(int x,int y,int dir,int triw,COLORREF color)
{
	SetPen(PS_SOLID,0,color);	
	
	int hs = (triw + 1)/2;
	for(int i = 0; i < hs; i++)
	{
		if(dir == TRI_LEFT)DrawLine(x+triw-hs-i,y+i,triw-hs+x-i,y+triw - i); 
		else if(dir == TRI_RIGHT)DrawLine(x+i,i + y,x+i,y+triw - i);
		else if(dir == TRI_UP)DrawLine(x + triw - hs - i,y+i,x +hs + i,y+i);
		else if(dir == TRI_DOWN)DrawLine(x + i,y+i,x + triw - i,y+i);
	}
	
	return OK;
}
int Draw3DBorder(CRect *r)
{
	int x1,x2,y;
	int x,y1,y2;
		
	x1 = r->left;
	x2 = r->right;
	y = r->top;
	
	SetPen(PS_SOLID,0,RGB(128,128,128));	
	DrawLine(x1,y,x2,y);
	SetPen(PS_SOLID,0,RGB(255,255,255));	
	DrawLine(x1+1,y+1,x2-1,y+1);
	
	y = r->bottom;
	SetPen(PS_SOLID,0,RGB(128,128,128));	
	DrawLine(x1+1,y-1,x2-1,y-1);
	SetPen(PS_SOLID,0,RGB(255,255,255));	
	DrawLine(x1,y,x2,y);

	y1 = r->top;
	y2 = r->bottom;
	x = r->left;
	SetPen(PS_SOLID,0,RGB(255,255,255));	
	DrawLine(x+1,y1+1,x+1,y2-1);
	SetPen(PS_SOLID,0,RGB(128,128,128));	
	DrawLine(x,y1,x,y2);
	
	x = r->right;
	SetPen(PS_SOLID,0,RGB(255,255,255));	
	DrawLine(x,y1,x,y2+1);
	SetPen(PS_SOLID,0,RGB(128,128,128));	
	DrawLine(x-1,y1+1,x-1,y2);
	
	return OK;
}
int DrawDefRect(CRect *rect,char *txt)
{
	SetSolidBrush(RGB(192,192,192));
	FillRect(rect);
	
	SetPen(PS_SOLID,0,RGB(0,0,255));	
	DrawRect(rect);
	
	SetTextColor(RGB(0,0,0));
	SetBkMode(TRANSPARENT);
	SetStockFont(DEFAULT_GUI_FONT);
	DrawText(txt,rect,DT_CENTER|DT_VCENTER|DT_SINGLELINE);
	
	return OK;
}
]]>
</file>
<file name="rect.h">
<![CDATA[
#ifndef __RECT_H
#define __RECT_H

#include "common.h"

typedef struct tagRECT
{
    int    left;
    int    top;
    int    right;
    int    bottom;
} RECT, *PRECT;

class CRect{
public:
	int left,top;
	int right,bottom;
public:
	int CenterRect(int w, int h, CRect *rc);
	int Copy(RECT *r);
	int SetPos(int x,int y);
	int Offset(int cx,int cy);
	int SetRect(int l,int t,int r,int b);
	int IsIntersect(CRect *pr);
	int Empty();
	int PtInRect(int x,int y);
	int Normalize();
	int SetHeight(int h);
	int SetWidth(int w);
	int GetHeight();
	int GetWidth();
    CRect();
    virtual ~CRect();
    int Init();
    int Destroy();
    int Copy(CRect *p);
    int Comp(CRect *p);
    int Print();
    int InitBasic();
};
#endif 
]]>
</file>
<file name="rect.cpp">
<![CDATA[
#include "Rect.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRect::CRect()
{
    this->InitBasic();
}
CRect::~CRect()
{
    this->Destroy();
}
int CRect::InitBasic()
{
	this->left = 0;
	this->top = 0;
	this->right = 0;
	this->bottom = 0;

    return OK;
}
int CRect::Init()
{
    this->InitBasic();
    //add your code
    return OK;
}
int  CRect::Destroy()
{
    //add your code
    this->InitBasic();
    return OK;
}
int  CRect::Copy(CRect *p)
{
	this->left = p->left;
	this->top = p->top;
	this->right = p->right;
	this->bottom = p->bottom;

    return OK;
}
int CRect::Comp(CRect *p)
{
    return 0;
}
int  CRect::Print()
{
	LOG("[%d,%d,%d,%d]",left,top,right,bottom);

    return TRUE;
}

int CRect::GetWidth()
{
	if(right >= left)
		return (right - left + 1);

	return (right - left - 1);
}

int CRect::GetHeight()
{
	if(bottom > top)
		return (bottom - top + 1);

	return (bottom - top - 1);
}

int CRect::SetWidth(int w)
{
	if(w == 0)	return OK;

	if(w > 0)
		this->right = this->left + w - 1;
	else
		this->right = this->left + w + 1;

	return OK;
}

int CRect::SetHeight(int h)
{
	if(h == 0)
		return OK;

	if(h > 0)
		this->bottom = this->top + h - 1;
	else
		this->bottom = this->top + h + 1;

	return OK;
}

int CRect::Normalize()
{
	int t;

	if(this->left > this->right)
	{
		t = this->left;
		this->left = this->right;
		this->right = t;
	}

	if(this->top > this->bottom)
	{
		t = this->bottom;
		this->bottom = this->top;
		this->top = t;
	}

	return OK;
}

int CRect::PtInRect(int x, int y)
{
	CRect r;

	r.Copy(this);
	r.Normalize();

	return ( x >= r.left && x <= r.right && y >= r.top && y <= r.bottom);
}

int CRect::Empty()
{
	return this->InitBasic();
}

int CRect::IsIntersect(CRect *pr)
{
	if(pr == NULL)
		return FALSE;
	
	CRect r1,r2;
    int left, top, right, bottom;

	r1.Copy(this);
	r2.Copy(pr);

	r1.Normalize();
	r2.Normalize();
 
    left = (r1.left > r2.left) ? r1.left : r2.left;
    top  = (r1.top > r2.top) ? r1.top : r2.top;
    right = (r1.right < r2.right) ? r1.right : r2.right;
    bottom = (r1.bottom < r2.bottom ) ? r1.bottom : r2.bottom;
    
	if(left > right || top > bottom)
        return FALSE;

    return TRUE;
}

int CRect::SetRect(int l, int t, int r, int b)
{
	this->left = l;
	this->top = t;
	this->right = r;
	this->bottom = b;

	return OK;
}

int CRect::Offset(int cx, int cy)
{
	this->left += cx;
	this->top += cy;
	this->right += cx;
	this->bottom += cy;

	return OK;
}

int CRect::SetPos(int x, int y)
{
	int w = this->GetWidth();
	int h = this->GetHeight();

	this->left = x;
	this->top = y;

	this->SetWidth(w);
	this->SetHeight(h);

	return OK;
}

int CRect::Copy(RECT *r)
{
	this->left = r->left;
	this->top = r->top;
	this->right = r->right;
	this->bottom = r->bottom;

	return OK;
}

int CRect::CenterRect(int w, int h, CRect *rc)
{
	rc->left = this->left + ( (this->GetWidth() - w) >> 1 );
	rc->right = rc->left + w - 1;
	rc->top = this->top + ( (this->GetHeight() - h) >> 1 );
	rc->bottom = rc->top + h - 1;

	return OK;
}

]]>
</file>



</Graphics>
<Main>
<file name="common.h">
<![CDATA[
#ifndef __COMMON_H
#define __COMMON_H

#include "init.h"
#include "stdio.h"
#include "malloc.h"
#include "stdlib.h"
#include "types.h"
#include "string.h"
#include "ctype.h"
#include "system.h"

#define _DEBUG_

#define LOG printf

#define PD(p) LOG("%s = %d\n",#p,p)
#define PX(p) LOG("%s = 0x%x\n",#p,p)
#define PS(p) LOG("%s = %s\n",#p,p)
#define PF(p) LOG("%s = %f\n",#p,p)
#define PQ(p) {QWORD *_v_ = (QWORD*)&(p);LOG("%s = ",#p);LOG("%08x%08x\n",*((int*)_v_ + 1),(int)(*_v_));}

#ifdef _DEBUG_
 #define ASSERT(f) if(!(f)){LOG("assertion fail \"%s\" at file=%s line=%d\n",#f,__FILE__,__LINE__);exit(0);}
#else
 #define ASSERT(f) 
#endif

#define NEW(p,obj)  {p = new obj;ASSERT(p);}
#define NEW_ARRAY(p,obj,items) {p = new obj[items];ASSERT(p);}
#define DEL(p) if(p){delete p;p = NULL;}
#define DEL_ARRAY(p) if(p){delete [] p;p = NULL;}
#define MALLOC(p,obj,items) {p = (obj*)malloc(sizeof(obj)*items);ASSERT(p);}
#define FREE(p) if(p){free(p);p = NULL;}
#define REALLOC(p,obj,old_items,items) if(p){p = (obj*)realloc(p,sizeof(obj)*old_items,sizeof(obj)*items);ASSERT(p);}

#define LBUF_SIZE 2048
#define FILEBASE_LBUF_SIZE	(8*1024)

#define float double

#endif
]]>
</file>
<file name="main.cpp">
<![CDATA[
#include "stdio.h"
#include "string.h"
#include "math.h"
#include "common.h"
#include "malloc.h"
#include "graphics.h"
#include "rect.h"
#include "mem.h"
#include "memfile.h"
#include "memstk.h"
#include "text.h"

int _init_attrib();
int before_draw();
int draw();
int code(int code_num);

#include "process.h"

int puts(const char *str)
{
	char ch = *str++;

	while(ch)
	{
		putchar(ch);
		ch = *str++;
	}

	return 1;
}

int main()
{
	int *p = (int *)0x30000000 + 9;
	int code_num = *(p+1);

	_init_attrib();
	
	switch(*p)
	{
		case 1: draw(); break;
		case 2: code(code_num); break;
		case 3: before_draw(); break;
	}
	
	return OK;
}
]]>
</file>
</Main>
</CommonFiles>
<UserLibs>
<AllFiles>
<file name="gui.h">
<![CDATA[
#ifndef __GUI_H
#define __GUI_H

int DrawButton(CRect *rect,char *caption);
int DrawWindow(CRect *rect,int title_height,char *caption);
int DrawStatic(CRect *rect,char *caption,int align);
int DrawGroupBox(CRect *rect,char *caption);
int DrawCheckBox(CRect *rect,char *caption);
int DrawRadioBox(CRect *rect,char *caption);
int DrawHScrollBar(CRect *rect);
int DrawVScrollBar(CRect *rect);
int DrawListBox(CRect *rect);
int DrawComboBox(CRect *rect);
int DrawEditBox(CRect *rect,char *txt);
int DrawMenuBar(CRect *rect,char **txts,int max_item);
int DrawMenuWnd(CRect *rect,char **txts,int max_item);
int DrawToolBar(CRect *rect,int tbbnum,int tbbw,int tbbh);
int DrawListView(CRect *rect,int *column,char **text);

#endif
]]>
</file>
<file name="gui.cpp">
<![CDATA[
#include "graphics.h"

int DrawButton(CRect *rect,char *caption)
{
	CRect r;
	
	r.Copy(rect);
	r.Normalize();
	
	Draw3DFrame(FRAME3D_UP,&r);
		
	SetTextColor(RGB(0,0,0));
	SetBkMode(TRANSPARENT);
	SetStockFont(DEFAULT_GUI_FONT);
	DrawText(caption,&r,DT_CENTER|DT_VCENTER|DT_SINGLELINE);
	
	return OK;
}

int DrawWindow(CRect *rect,int title_height,char *caption)
{
	CRect r,rt;
	
	r.Copy(rect);
	r.Normalize();
	
	Draw3DFrame(FRAME3D_UP,&r);

	rt.Copy(&r);
	rt.left += 2;rt.top+=2;
	rt.right -= 2; 

	if(rt.bottom > title_height)
		rt.bottom = rt.top + title_height;
		
	SetSolidBrush(RGB(75,80,253));
	FillRect(&rt);
	
	SetTextColor(RGB(255,255,255));
	SetBkMode(TRANSPARENT);
	SetStockFont(DEFAULT_GUI_FONT);
	DrawText(caption,&rt,DT_VCENTER|DT_SINGLELINE);
	
	return OK;
}

int DrawStatic(CRect *rect,char *caption,int align)
{
	CRect r;
	
	r.Copy(rect);
	
	r.Normalize();
	
	SetPen(PS_DOT,0,RGB(212,212,212));
	DrawRect(&r);
	
	SetTextColor(RGB(0,0,0));
	SetBkMode(TRANSPARENT);
	SetStockFont(DEFAULT_GUI_FONT);
	if(align == 1)DrawText(caption,&r,DT_SINGLELINE|DT_VCENTER);
	if(align == 2)DrawText(caption,&r,DT_RIGHT|DT_SINGLELINE|DT_VCENTER);
	if(align == 3)DrawText(caption,&r,DT_CENTER|DT_SINGLELINE|DT_VCENTER);

	return OK;
}
int DrawGroupBox(CRect *rect,char *caption)
{
	CRect r,rt;
	
	r.Copy(rect);
	r.Normalize();
	
	rt.Copy(&r);
	if(caption[0])
		rt.top += 6;
	Draw3DBorder(&rt);
	rt.Copy(&r);
	rt.left += 8;
	SetTextColor(RGB(0,0,0));
	SetBkColor(RGB(192,192,192));
	SetBkMode(OPAQUE);
	SetStockFont(DEFAULT_GUI_FONT);
	DrawText(caption,&rt,DT_SINGLELINE);

	return OK;
}
int DrawCheckBox(CRect *rect,char *caption)
{
		
	CRect r,rt;
	int bs = 10;
	
	r.Copy(rect);
	r.Normalize();
	
	rt.left = r.left;
	rt.right = r.left + bs;
	rt.top = r.top + (r.GetHeight() - bs)/2;
	rt.bottom = rt.top + bs;
	
	SetPen(PS_DOT,0,RGB(212,212,212));
	DrawRect(&r);

	Draw3DFrame(FRAME3D_DOWN,&rt);
	SetSolidBrush(RGB(255,255,255));
	
	rt.left += 2;
	rt.right -= 2;
	rt.top += 2;
	rt.bottom -= 2;
			
	FillRect(&rt);
	
	rt.Copy(&r);
	r.left += (bs + 3);
	
	SetTextColor(RGB(0,0,0));
	SetBkMode(TRANSPARENT);
	SetStockFont(DEFAULT_GUI_FONT);
	DrawText(caption,&r,DT_VCENTER|DT_SINGLELINE);

	return OK;
}
int DrawRadioBox(CRect *rect,char *caption)
{
		
	CRect r,rt;
	int bs = 11;
	
	r.Copy(rect);
	r.Normalize();
	
	SetPen(PS_DOT,0,RGB(212,212,212));
	DrawRect(&r);
	
	rt.left = r.left;
	rt.right = r.left + bs;
	rt.top = r.top + (r.GetHeight() - bs)/2;
	rt.bottom = rt.top + bs;	
		
	SetPen(PS_SOLID,0,RGB(255,255,255));
	SetSolidBrush(RGB(255,255,255));
	Ellipse(&rt);
	SetPen(PS_SOLID,0,RGB(128,128,128));
	Arc(rt.left,rt.top,rt.right,rt.bottom,
			rt.right,rt.top,rt.left,rt.bottom);
	rt.left += 1;rt.top += 1;
	rt.right -= 1;rt.bottom -=1;
	SetPen(PS_SOLID,0,RGB(0,0,0));
	Arc(rt.left,rt.top,rt.right,rt.bottom,
			rt.right,rt.top,rt.left,rt.bottom);			
	SetPen(PS_SOLID,0,RGB(128,128,128));
	Arc(rt.left,rt.top,rt.right,rt.bottom,
			rt.left,rt.bottom,rt.right,rt.top);			
	
	rt.Copy(&r);
	r.left += (bs + 3);
	
	SetTextColor(RGB(0,0,0));
	SetBkMode(TRANSPARENT);
	SetStockFont(DEFAULT_GUI_FONT);
	DrawText(caption,&r,DT_VCENTER|DT_SINGLELINE);

	return OK;
}
int DrawHScrollBar(CRect *rect)
{
	CRect r,rt;
	int ml,mr,hw,triw;
	
	r.Copy(rect);
	r.Normalize();
	
	rt.Copy(&r);
	rt.right = rt.left + 16;
	hw = r.GetWidth()/2;
	if(rt.right > r.left + hw)
		rt.right = r.left + hw;
	ml = rt.right + 1;	
	
	Draw3DFrame(FRAME3D_UP,&rt);
	triw = 5;
	if(triw > rt.GetWidth())triw =  rt.GetWidth();
	if(triw > rt.GetHeight())triw =  rt.GetHeight();
		
	DrawSmallTriangle(rt.left+(rt.GetWidth()-triw/2)/2,rt.top+(rt.GetHeight()-triw)/2,
	                  TRI_LEFT,triw,RGB(0,0,0));	
	
	rt.Copy(&r);
	rt.left = rt.right - 16;
	if(rt.left < r.left + hw)
		rt.left = r.left + hw;		
	mr = rt.left - 1;	
	Draw3DFrame(FRAME3D_UP,&rt);

	DrawSmallTriangle(rt.left+(rt.GetWidth()-triw/2)/2,rt.top+(rt.GetHeight()-triw)/2,
	                  TRI_RIGHT,triw,RGB(0,0,0));	
		
	rt.Copy(&r);
	rt.left = ml;
	rt.right = mr;
	
	SetSolidBrush(RGB(128,128,128));
	FillRect(&rt);
	
	rt.right = ml + 30;
	if(rt.right > mr)
		rt.right = mr;	
	Draw3DFrame(FRAME3D_UP,&rt);
	
	return OK;
}
int DrawVScrollBar(CRect *rect)
{
	CRect r,rt;
	int mt,mb,hw,triw;
	
	r.Copy(rect);
	r.Normalize();
	
	rt.Copy(&r);
	rt.bottom = rt.top + 16;
	hw = r.GetHeight()/2;
	if(rt.bottom > r.top + hw)
		rt.bottom = r.top + hw;
	mt = rt.bottom + 1;	
	
	Draw3DFrame(FRAME3D_UP,&rt);
	triw = 5;
	if(triw > rt.GetWidth())triw =  rt.GetWidth();
	if(triw > rt.GetHeight())triw =  rt.GetHeight();
		
	DrawSmallTriangle(rt.left+(rt.GetWidth()-triw)/2,rt.top+(rt.GetHeight()-triw/2)/2,
	                  TRI_UP,triw,RGB(0,0,0));	
	
	rt.Copy(&r);
	rt.top = rt.bottom -16;
	if(rt.top < r.top + hw)
		rt.top = r.top + hw;		
	mb = rt.top - 1;	
	Draw3DFrame(FRAME3D_UP,&rt);

	DrawSmallTriangle(rt.left+(rt.GetWidth()-triw)/2,rt.top+(rt.GetHeight()-triw/2)/2,
	                  TRI_DOWN,triw,RGB(0,0,0));	
		
	rt.Copy(&r);
	rt.top = mt;
	rt.bottom = mb;
	
	SetSolidBrush(RGB(128,128,128));
	FillRect(&rt);
	
	rt.bottom = mt + 30;
	if(rt.bottom > mb)
		rt.bottom = mb;	
	Draw3DFrame(FRAME3D_UP,&rt);
	
	return OK;
}
int DrawListBox(CRect *rect)
{
		
	CRect r;
	
	r.Copy(rect);
	r.Normalize();
	
	Draw3DFrame(FRAME3D_DOWN,&r);
	
	r.left += 2;r.top +=2;
	r.right -= 2; r.bottom -=2;
	
	SetSolidBrush(RGB(255,255,255));	
	FillRect(&r);
	int item_height = 15;
	
	int max_line = r.GetHeight() / item_height;
	
	SetPen(PS_SOLID,0,RGB(212,212,212));
	for(int i = 1; i<=max_line; i++)
	{
		DrawLine(r.left, r.top + i * item_height,r.right,r.top + i * item_height);
	}
	SetTextColor(RGB(212,212,212));
	SetBkMode(TRANSPARENT);
	SetStockFont(DEFAULT_GUI_FONT);
	DrawText("List Box",&r,NULL);
	
	return OK;
}
int DrawComboBox(CRect *rect)
{
	CRect r,rt;
		
	r.Copy(rect);
	r.Normalize();
	
	SetPen(PS_DOT,0,RGB(212,212,212));
	DrawRect(&r);
	
	rt.Copy(&r);
	rt.bottom = r.top + 17;
	if(rt.bottom > r.bottom)
		rt.bottom = r.bottom;
		
	Draw3DFrame(FRAME3D_DOWN,&rt);
	
	rt.left += 2;rt.top +=2;
	rt.right -= 2; rt.bottom -= 2;
	
	SetSolidBrush(RGB(255,255,255));	
	FillRect(&rt);
	
	rt.left = rt.right - 13;
	if(rt.left < r.left)
		rt.left = r.left;
	Draw3DFrame(FRAME3D_UP,&rt);
	
	int triw = 5;
	DrawSmallTriangle(rt.left+(rt.GetWidth()-triw)/2,rt.top+(rt.GetHeight()-triw/2)/2,
	                  TRI_DOWN,triw,RGB(0,0,0));	
	
	return OK;
}
int DrawEditBox(CRect *rect,char *txt)
{
		
	CRect r;
	
	r.Copy(rect);
	r.Normalize();
	
	Draw3DFrame(FRAME3D_DOWN,&r);
	
	r.left += 2;r.top +=2;
	r.right -= 2; r.bottom -=2;
	
	SetSolidBrush(RGB(255,255,255));	
	FillRect(&r);

	SetTextColor(RGB(212,212,212));
	SetBkMode(TRANSPARENT);
	SetStockFont(DEFAULT_GUI_FONT);
	DrawText(txt,&r,NULL);
	
	return OK;
}
int DrawMenuBar(CRect *rect,char **txts,int max_item)
{
	CRect r,rt;
	char buf[2048];
	
	r.Copy(rect);
	r.Normalize();

	SetSolidBrush(RGB(192,192,192));	
	FillRect(&r);

	buf[0] = 0;
	for(int i = 0; i < max_item; i++)
	{
		if(txts[i])
		{
			strcat(buf, txts[i]);
			strcat(buf,"  ");
		}
	}	

	SetTextColor(RGB(0,0,0));
	SetBkMode(TRANSPARENT);
	SetStockFont(DEFAULT_GUI_FONT);
	DrawText(buf,&r,NULL);
	
	return OK;
}
int DrawMenuWnd(CRect *rect,char **txts,int max_item)
{
	CRect r,rt;
	int pos = 0;
		
	r.Copy(rect);
	r.Normalize();

	Draw3DFrame(FRAME3D_UP,&r);

	SetTextColor(RGB(0,0,0));
	SetBkMode(TRANSPARENT);
	SetStockFont(DEFAULT_GUI_FONT);
	
	for(int i = 0; i < max_item; i++)
	{
		if(txts[i])
		{
			rt.Copy(&r);
			rt.top += 3;
			rt.right -= 3;
			rt.left += 3;
			rt.top += pos;

			if(txts[i][0] == '-')
			{
				Draw3DHLine(rt.left,rt.right,rt.top+6);
			}
			else
			{
				DrawText(txts[i],&rt,NULL);
			}
			pos += 15;
		}
	}	

	return OK;
}

int DrawToolBar(CRect *rect,int tbbnum,int tbbw,int tbbh)
{
	
	CRect r;
	int i;
	
	SetSolidBrush(RGB(192,192,192));
	FillRect(rect);	

	for(i = 0; i < tbbnum; i++)
	{
		r.left = rect->left + i * tbbw + 3*i;
		r.top = rect->top + (rect->GetHeight() - tbbh) / 2;
		r.right = tbbw + r.left;
		r.bottom = r.top + tbbh;
		
		Draw3DFrame(1,&r);
	}
	
	return OK;
}

int DrawListView(CRect *rect,int *column,char **text)
{
	int total_len = 0;
	int i = 0,max,width;
	CRect r,rt;
	
	i = 0;
	
	DrawListBox(rect);
	while(column[i] > 0)
	{
		total_len += column[i++];
	}
	
	max = i;
	width = rect->GetWidth();
	
	r.left = rect->left + 1;

	SetTextColor(RGB(0,0,0));
	SetBkMode(TRANSPARENT);
	SetStockFont(DEFAULT_GUI_FONT);
	
	for(i = 0; i < max; i++)
	{
		r.top = rect->top + 1;
		r.right = r.left + column[i] * width / total_len - 1;
		r.bottom = r.top + 16;
		Draw3DFrame(FRAME3D_UP,&r);
		rt.Copy(&r);
		rt.left += 2;
		rt.top += 2;
		DrawText(text[i],&rt,NULL);
		r.left = r.right+1;		
	}
	
	return OK;
}
]]>
</file>
</AllFiles>
</UserLibs>

<PCB>
<AllFiles>

<file name="pcb.h">
<![CDATA[

#ifndef __PCB_H
#define __PCB_H

#include "rect.h"
#include "graphics.h"

#define HOLE_WIDTH 16

void align(int *t);
int align_rect(CRect *r,int norm);
int fix_rect(CRect *r,int w,int h);
int fix_rect_pos(CRect *r,int l,int t);
int draw_connect_dot(int x,int y);
int fix_rect_min_abs_width(CRect *r,int w);
int fix_rect_min_abs_height(CRect *r,int h);
int	DrawRect_2(CRect *r);
#endif

]]>
</file>

<file name="pcb.cpp">
<![CDATA[
#include "pcb.h"

void align(int *t)
{
	if((*t % HOLE_WIDTH) < (HOLE_WIDTH/2))
		*t = (*t / HOLE_WIDTH) * HOLE_WIDTH;
	else
		*t = ((*t + HOLE_WIDTH) / HOLE_WIDTH) * HOLE_WIDTH;
}

int is_align(int t)
{
	return (t % HOLE_WIDTH) == 0;
}
int align_rect(CRect *r,int norm)
{
	if(norm)
		r->Normalize();
	
	if(r->left < 0)r->left = 0;
	if(r->top < 0) r->top = 0;
	
	int w = r->right - r->left + 1;
	int h = r->bottom - r->top + 1;
			
	align(&r->left);
	align(&r->top);

	r->right = r->left + w -1;
	r->bottom =  r->top + h - 1;

	align(&r->right);
	align(&r->bottom);
	
	return OK;
}

int fix_rect(CRect *r,int w,int h)
{
		r->right = r->left + w -1;
		r->bottom = r->top + h -1;		
		return OK;	
}

int fix_rect_pos(CRect *r,int l,int t)
{
	int w = r->right - r->left + 1;
	int h = r->bottom - r->top + 1;
	
	r->left = l;
	r->top = t;
	
	fix_rect(r,w,h);
	
	return OK;
}

int fix_rect_min_abs_width(CRect *r,int w)
{
	int rw = r->GetWidth();
	
	if(rw < 0)
	{
		if(rw > -w)
			r->SetWidth(-w);
	}
	else
	{
		if(rw < w)
			r->SetWidth(w);
	}
		
	return OK;
}
int fix_rect_min_abs_height(CRect *r,int h)
{
	int rh = r->GetHeight();
	
	if(rh < 0)
	{
		if(rh > -h)
			r->SetHeight(-h);
	}
	else
	{
		if(rh < h)
			r->SetHeight(h);
	}
		
	return OK;		
}
int draw_connect_dot(int x,int y)
{
	int dot_width = 3;
	
	CRect r;
	
	r.left = x - dot_width;
	r.right = x + dot_width;
	r.top = y - dot_width;
	r.bottom = y + dot_width;
	
	SetPen(PS_SOLID,1,RGB(255,0,0));
	SetSolidBrush(RGB(255,0,0));
	Ellipse(&r);
	
	return OK;	
}

int	DrawRect_2(CRect *r)
{
	line(r->left,r->top+1,r->right,r->top+1);
	line(r->left,r->top,r->left,r->bottom);
	line(r->right,r->top,r->right,r->bottom);
	line(r->left,r->bottom,r->right,r->bottom);

	return OK;
}

]]>
</file>

</AllFiles>
</PCB>

<AllNode isnode="true" icon="1">
<Graphics isnode="true" icon="9">
<Line isnode="true">
<code>
<![CDATA[

COLORREF color;
int width,style;

int code_0()
{
	CRect r;
	
	GetRect(&r);
	
	printf("Line %d,%d,%d,%d,%d,%d,%d\n",r.left,r.top,r.right,r.bottom,width,style,color);
	
	return OK;
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0:code_0();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;

	GetRect(&r);
	
	SetPen(style,width,color);
	DrawLine(r.left,r.top,r.right,r.bottom);
	
	return OK;
}
]]>
</code>
<default>
<![CDATA[
color = RGB(0,0,0);
width = 1;
style = 0;
/*****
style
0 = SOLID
1 = DASH
2 = DOT
3 = DASHDOT
4 = PS_DASHDOTDOT
*****/
]]>
</default>
</Line>
<Rect isnode="true">
<code>
<![CDATA[

COLORREF border_color;
COLORREF fill_color;
int pen_style,pen_width;
int fill_obj;
int has_border;

int code_0()
{
	CRect r;
	
	GetRect(&r);
	
	printf("Rect %d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
					r.left,r.top,r.right,r.bottom,
					pen_style,pen_width,
					has_border,fill_obj,
					border_color,fill_color);
					
	return OK;
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0:code_0();break;
	}
  return OK;
}

int before_draw()
{
	return OK;
}

int draw()
{
	CRect r;
	
	GetRect(&r);

	if(fill_obj)
	{
		SetSolidBrush(fill_color);
		FillRect(&r);
	}
	
	if(has_border)
	{
		SetPen(pen_style,pen_width,border_color);
		DrawRect(&r);
	}
	
	return OK;
}
]]>
</code>
<default>
<![CDATA[
has_border = 1;
pen_width = 0;
border_color = RGB(0,0,0);
fill_obj = 1;
fill_color = RGB(250,210,210);
pen_style = 0;
/*****
pen_style
0 = SOLID
1 = DASH
2 = DOT
3 = DASHDOT
4 = PS_DASHDOTDOT
*****/
]]>
</default>
</Rect>
<HorzLine isnode="true">
<code>
<![CDATA[

COLORREF color;
int style,width;

int code_0()
{
	CRect r;
	
	GetRect(&r);
	
	printf("HLine %d,%d,%d,%d,%d,%d\n",r.left,r.top,r.right,style,width,color);
	
	return OK;
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0: code_0();break;
	}
  return OK;
}

int before_draw()
{
	return OK;
}

int draw()
{
	CRect r,rt;
	
	GetRect(&r);
  r.Normalize();
  rt.Copy(&r);
  
  rt.bottom = rt.top + 6;
 	SetRect(&rt);

	SetPen(style,width,color);
	
	DrawLine(r.left,r.top,r.right,r.top);
		
	return OK;
}
]]>
</code>
<default>
<![CDATA[
color = RGB(0,0,0);
width = 1;
style = 0;
/*****
style
0 = SOLID
1 = DASH
2 = DOT
3 = DASHDOT
4 = PS_DASHDOTDOT
*****/

]]>
</default>
</HorzLine>
<VertLine isnode="true">
<code>
<![CDATA[

COLORREF color;
int style,width;

int code_0()
{
	CRect r;
	
	GetRect(&r);
	
	printf("VLine %d,%d,%d,%d,%d,%d\n",r.left,r.top,r.bottom,style,width,color);
	
	return OK;
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0:code_0();break;
	}
  return OK;
}

int before_draw()
{
	return OK;
}

int draw()
{
	CRect r,rt;
	
	GetRect(&r);
  r.Normalize();
  rt.Copy(&r);
  
  rt.right = rt.left + 6;
 	SetRect(&rt);
	SetPen(style,width,color);
	DrawLine(r.left,r.top,r.left,r.bottom);
		
	return OK;
}
]]>
</code>
<default>
<![CDATA[
color = RGB(0,0,0);
width = 1;
style = 0;
/*****
style
0 = SOLID
1 = DASH
2 = DOT
3 = DASHDOT
4 = PS_DASHDOTDOT
*****/
]]>
</default>
</VertLine>
<Label isnode="true">
<code>
<![CDATA[
#define MAX_FORMAT	20
COLORREF border_color,text_color;
char *text;
LOGFONT log_font;
int has_border;

int format[MAX_FORMAT];

int init()
{
	int i;
	for(i = 0; i < MAX_FORMAT; i++)
		format[i] = 0;
		
	_init_attrib();	
	return OK;
}
int code(int code_num)
{
  return OK;
}

int before_draw()
{
	return OK;
}

int draw()
{
	CRect r;

	init();
	
	GetRect(&r);
	r.Normalize();
	
	SetBkMode(TRANSPARENT);
	SetTextColor(text_color);
	SetFont(&log_font);
	
	DWORD style = 0;
	
	if(format[0]) style |= DT_TOP;
	if(format[1]) style |= DT_LEFT;
	if(format[2]) style |= DT_CENTER;
	if(format[3]) style |= DT_RIGHT;
	if(format[4]) style |= DT_VCENTER;
	if(format[5]) style |= DT_BOTTOM;
	if(format[6]) style |= DT_WORDBREAK;
	if(format[7]) style |= DT_SINGLELINE;

	
	DrawText(text,&r,style);
	
	if(has_border)
	{
		SetPen(PS_SOLID,0,border_color);
		DrawRect(&r);
	}
	return OK;
}
]]>
</code>
<default>
<![CDATA[
text = "Label";
text_color = RGB(0,0,0);
has_border = 0;
border_color = RGB(0,0,0);

format[0] = 1;  //DT_TOP
format[1] = 1;  //DT_LEFT
format[2] = 0;  //DT_CENTER
format[3] = 0;  //DT_RIGHT
format[4] = 0;  //DT_VCENTER
format[5] = 0;  //DT_BOTTOM
format[6] = 1;  //DT_WORDBREAK
format[7] = 0;  //DT_SINGLELINE


/***log font***/
log_font.lfHeight = -16;
log_font.lfWidth = 0;
log_font.lfEscapement = 0;
log_font.lfWeight = 400;
log_font.lfItalic = 0;
log_font.lfUnderline = 0;
log_font.lfStrikeOut = 0;
strcpy(log_font.lfFaceName,"Arial");
/**************/

]]>
</default>
</Label>
<Table isnode="true">
<code>
<![CDATA[
#define MAX_FORMAT	20

COLORREF border_color,text_color;
char *text;
LOGFONT log_font;
int has_border;
int row,col;
int format[MAX_FORMAT];

int init()
{
	int i;
	for(i = 0; i < MAX_FORMAT; i++)
		format[i] = 0;
		
	_init_attrib();	
	return OK;
}

int LoadText(CMemStk *stk)
{
	ASSERT(stk);
	stk->Clear();
	
	CMem mem,buf;
	mem.Init();
	mem.SetP(text);
	LOCAL_MEM(buf);
	
	mem.Seek(0);
	while(mem.ReadLine(&buf))
	{
		if(buf.p[0] == 0)
			continue;
			
		stk->Push(&buf);
	}
	
	return OK;
}

int code(int code_num)
{
  return OK;
}

int before_draw()
{
	return OK;
}

int draw()
{
	CRect r;
	CMemStk stk;
	
	stk.Init(1024);
	
	init();
	LoadText(&stk);
	
	GetRect(&r);
	r.Normalize();
	
	SetBkMode(TRANSPARENT);
	SetTextColor(text_color);
	SetFont(&log_font);
	
	DWORD style = 0;
	
	if(format[0]) style |= DT_TOP;
	if(format[1]) style |= DT_LEFT;
	if(format[2]) style |= DT_CENTER;
	if(format[3]) style |= DT_RIGHT;
	if(format[4]) style |= DT_VCENTER;
	if(format[5]) style |= DT_BOTTOM;
	if(format[6]) style |= DT_WORDBREAK;
	if(format[7]) style |= DT_SINGLELINE;
	
	int i,j,x,y;
	CRect rt;
	CMem *pmem;
	
	ASSERT(col && row);

#define yy 	r.GetWidth() / col
#define xx 	r.GetHeight() / row
	
	SetPen(PS_SOLID,0,border_color);
	
	if(has_border)
	{
		for(i = 0; i < row; i++)
		{
			x = r.left;
			y = r.top + (i*xx);
			DrawLine(x,y,x + r.GetWidth(),y);
		}
		for(i = 0; i < col; i++)
		{
			x = r.left + (yy * i);
			y = r.top;
			DrawLine(x,y,x,y+r.GetHeight());
		}
		
		DrawLine(r.right,r.top,r.right,r.bottom);
		DrawLine(r.left,r.bottom,r.right,r.bottom);
	}
	for(i = 0; i < row; i++)
	{
		for(j = 0; j < col; j++)
		{
			rt.left = r.left + (j*yy);
			rt.top = r.top + (i*xx);
			rt.SetWidth(yy);
			rt.SetHeight(xx);
			
			pmem = stk.GetElem(i*col + j);
			if(pmem)
				DrawText(pmem->p,&rt,style);
		}
	}
	
	return OK;
}
]]>
</code>
<default>
<![CDATA[

row = 3;	//
col = 3;	//
//
text = "Label";	

text_color = RGB(0,0,0);
has_border = 1;
border_color = RGB(0,0,0);

format[0] = 0;  //DT_TOP
format[1] = 0;  //DT_LEFT
format[2] = 1;  //DT_CENTER
format[3] = 0;  //DT_RIGHT
format[4] = 1;  //DT_VCENTER
format[5] = 0;  //DT_BOTTOM
format[6] = 0;  //DT_WORDBREAK
format[7] = 1;  //DT_SINGLELINE

/***log font***/
log_font.lfHeight = -16;
log_font.lfWidth = 0;
log_font.lfEscapement = 0;
log_font.lfWeight = 400;
log_font.lfItalic = 0;
log_font.lfUnderline = 0;
log_font.lfStrikeOut = 0;
strcpy(log_font.lfFaceName,"Arial");
/**************/

]]>
</default>
</Table>

<Ellipse isnode="true">
<code>
<![CDATA[

COLORREF border_color;
COLORREF fill_color;
int pen_style,pen_width;
int fill_obj;
int has_border;

int code(int code_num)
{
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;
	
	GetRect(&r);

	r.Normalize();
	
	if(fill_obj)
	{
		SetSolidBrush(fill_color);
		Ellipse(&r);
	}
	
	if(has_border)
	{
		SetPen(pen_style,pen_width,border_color);
		Arc(r.left,r.top,r.right,r.bottom,r.left,r.top,r.left,r.top);
	}
	
	return OK;
}
]]>
</code>
<default>
<![CDATA[
has_border = 1;
pen_width = 0;
border_color = RGB(0,0,0);
pen_style = 0;
/*****
pen_style
0 = SOLID
1 = DASH
2 = DOT
3 = DASHDOT
4 = PS_DASHDOTDOT
*****/

fill_obj = 1;
fill_color = RGB(250,210,210);
]]>
</default>
</Ellipse>
</Graphics>
<Controls isnode="true" icon="6">
<HLine_3D isnode="true" icon="7" include="/WorkShop/UserLibs">
<code>
<![CDATA[

char *var;

void code_0()
{
}
void code_1()
{
	LOG("CStatic *%s;\n",var);
}
void code_2()
{	
	LOG("this->%s = NULL;\n",var);	
}
void code_3()
{
	LOG("NEW(this->%s,CStatic);\r\n",var);
	LOG("this->%s->Init();\r\n",var);
	LOG("this->%s->SetParent(hwnd);\r\n",var);
	LOG("this->%s->AddStyle(SS_ETCHEDHORZ);\n",var);
	LOG("this->%s->Create();\r\n",var);
}
void code_4()
{
	LOG("DEL(this->%s);\n",var);
}
void code_5()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->%s->MoveWindow(x+%d,y+%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),2);
}
void code_6()
{
	CRect r;
	GetRect(&r);
	r.Normalize();

	LOG("this->MoveChildWindow(%s->hwnd,%d,%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),2);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0:code_0();break;
		case 1:code_1();break;
		case 2:code_2();break;
		case 3:code_3();break;
		case 4:code_4();break;
		case 5:code_5();break;
		case 6:code_6();break;
	}
  return OK;
}

int before_draw()
{
	return OK;
}
int draw()
{
	CRect r,rt;
		
	GetRect(&r);
  r.Normalize();
  rt.Copy(&r);
  
  rt.bottom = rt.top + 6;
 	SetRect(&rt);
 	
 	SetPen(PS_DOT,0,RGB(212,212,212));
	DrawRect(&r);
	
	Draw3DHLine(r.left,r.right,r.top);
		
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="st_";
]]>
</default>
</HLine_3D>
<VLine_3D isnode="true" icon="8" include="/WorkShop/UserLibs">
<code>
<![CDATA[

char *var;

void code_0()
{
}
void code_1()
{
LOG("CStatic *%s;\n",var);
}
void code_2()
{
LOG("this->%s = NULL;\n",var);	
}
void code_3()
{
LOG("NEW(this->%s,CStatic);\r\n",var);
LOG("this->%s->Init();\r\n",var);
LOG("this->%s->SetParent(hwnd);\r\n",var);
LOG("this->%s->AddStyle(SS_ETCHEDVERT);\n",var);
LOG("this->%s->Create();\r\n",var);
}
void code_4()
{
	LOG("DEL(this->%s);\n",var);
}
void code_5()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->%s->MoveWindow(x+%d,y+%d,%d,%d);\r\n",var,r.left,r.top,2,r.GetHeight());
}
void code_6()
{
	CRect r;
	GetRect(&r);
	r.Normalize();

	LOG("this->MoveChildWindow(%s->hwnd,%d,%d,%d,%d);\r\n",var,r.left,r.top,2,r.GetHeight());
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0:code_0();break;
		case 1:code_1();break;
		case 2:code_2();break;
		case 3:code_3();break;
		case 4:code_4();break;
		case 5:code_5();break;
		case 6:code_6();break;
	}
  return OK;
}

int before_draw()
{
	return OK;
}
int draw()
{
	CRect r,rt;
		
	GetRect(&r);
  r.Normalize();
  rt.Copy(&r);
  
  rt.right= rt.left + 6;
 	SetRect(&rt);
	SetPen(PS_DOT,0,RGB(212,212,212));
	DrawRect(&r);
	Draw3DVLine(r.left,r.top,r.bottom);
		
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="st_";
]]>
</default>
</VLine_3D>
<Static isnode="true" icon="9" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *var,*caption;
int align;
int border;

void code_0()
{
}
void code_1()
{
LOG("CStatic *%s;\n",var);
}
void code_2()
{
LOG("this->%s = NULL;\n",var);	
}
void code_3()
{
LOG("NEW(this->%s,CStatic);\r\n",var);
LOG("this->%s->Init();\r\n",var);
LOG("this->%s->SetParent(hwnd);\r\n",var);
LOG("this->%s->SetText(L\"%s\");\r\n",var,caption);
if(border) LOG("this->%s->AddStyle(WS_BORDER);\n",var);
if(align == 2) LOG("this->%s->AddStyle(SS_RIGHT);\n",var);
if(align == 3) LOG("this->%s->AddStyle(SS_CENTER);\n",var);
LOG("this->%s->Create();\r\n",var);
LOG("this->%s->SetStockFont(DEFAULT_GUI_FONT);\r\n",var);
}
void code_4()
{
	LOG("DEL(this->%s);\n",var);
}
void code_5()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->%s->MoveWindow(x+%d,y+%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
void code_6()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->MoveChildWindow(%s->hwnd,%d,%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}

int code(int code_num)
{
	switch(code_num)
	{
		case 0:code_0();break;
		case 1:code_1();break;
		case 2:code_2();break;
		case 3:code_3();break;
		case 4:code_4();break;
		case 5:code_5();break;
		case 6:code_6();break;
	}
  return OK;
}

int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;
	
	GetRect(&r);
	r.Normalize();
	
  DrawStatic(&r,caption,align);


	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="st_";
caption = "static";
border = 0;
align = 1;

/******
align
1 = Left
2 = Right
3 = Center
******/

]]>
</default>
</Static>
<EditBox_SingleLine isnode="true" icon="33" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *var;

int max_size;
int read_only;
int auto_h_scroll;
int edge_type;
int password;

void code_0()
{
}
void code_1()
{
LOG("CEditBox *%s;\n",var);
}
void code_2()
{
LOG("this->%s = NULL;\n",var);	
}
void code_3()
{
LOG("NEW(this->%s,CEditBox);\r\n",var);
LOG("this->%s->Init();\r\n",var);
LOG("this->%s->SetParent(hwnd);\r\n",var);
if(auto_h_scroll)LOG("this->%s->AddStyle(ES_AUTOHSCROLL);\n",var);
if(edge_type == 0)
	LOG("this->%s->AddExStyle(WS_EX_STATICEDGE);\n",var);
else if(edge_type == 1)
	LOG("this->%s->AddExStyle(WS_EX_CLIENTEDGE);\n",var);
else if(edge_type == 2) 
	LOG("this->%s->AddStyle(WS_BORDER);\n",var);
if(password)
	LOG("this->%s->AddStyle(ES_PASSWORD);\n",var);
LOG("this->%s->Create();\r\n",var);
LOG("this->%s->SetStockFont(DEFAULT_GUI_FONT);\r\n",var);
if(max_size > 0)
	LOG("this->%s->SetMaxText(%d);\n",var,max_size);
}
void code_4()
{
	LOG("DEL(this->%s);\n",var);
}
void code_5()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->%s->MoveWindow(x+%d,y+%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
void code_6()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->MoveChildWindow(%s->hwnd,%d,%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
void code_7()
{
	LOG("hlist[i++] = %s->hwnd;\n",var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0:code_0();break;
		case 1:code_1();break;
		case 2:code_2();break;
		case 3:code_3();break;
		case 4:code_4();break;
		case 5:code_5();break;
		case 6:code_6();break;
		case 7:code_7();break;
	}
  return OK;
}

int before_draw()
{
	return OK;
}
int draw()
{
		
	CRect r;
	
	GetRect(&r);
	r.Normalize();
	
	DrawEditBox(&r,"Text Box(Single line)");
	
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="eb_";

max_size = 0;	//0 is auto
read_only = 0;
auto_h_scroll = 1;
edge_type = 1;
/*****
0 = static edge
1 = client edge
2 = normal border
*****/
password = 0;

]]>
</default>
</EditBox_SingleLine>
<EditBox_MultiLine isnode="true" icon="10" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *var;

int max_size;
int read_only;
int auto_h_scroll;
int auto_v_scroll;
int h_scroll_bar;
int v_scroll_bar;
int want_return;
int edge_type;

void code_0()
{
}
void code_1()
{
LOG("CEditBox *%s;\n",var);
}
void code_2()
{
LOG("this->%s = NULL;\n",var);	
}
void code_3()
{
LOG("NEW(this->%s,CEditBox);\r\n",var);
LOG("this->%s->Init();\r\n",var);
LOG("this->%s->SetParent(hwnd);\r\n",var);
LOG("this->%s->AddStyle(ES_MULTILINE);\n",var);

if(h_scroll_bar)LOG("this->%s->AddStyle(WS_HSCROLL);\n",var);
if(v_scroll_bar)LOG("this->%s->AddStyle(WS_VSCROLL);\n",var);
if(auto_h_scroll)LOG("this->%s->AddStyle(ES_AUTOHSCROLL);\n",var);
if(auto_v_scroll)LOG("this->%s->AddStyle(ES_AUTOVSCROLL);\n",var);

if(edge_type == 0)
	LOG("this->%s->AddExStyle(WS_EX_STATICEDGE);\n",var);
else if(edge_type == 1)
	LOG("this->%s->AddExStyle(WS_EX_CLIENTEDGE);\n",var);
else if(edge_type == 2) 
	LOG("this->%s->AddStyle(WS_BORDER);\n",var);

LOG("this->%s->Create();\r\n",var);
LOG("this->%s->SetStockFont(DEFAULT_GUI_FONT);\r\n",var);
if(max_size > 0)
	LOG("this->%s->SetMaxText(%d);\n",var,max_size);
}
void code_4()
{
	LOG("DEL(this->%s);\n",var);
}
void code_5()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->%s->MoveWindow(x+%d,y+%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
void code_6()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->MoveChildWindow(%s->hwnd,%d,%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
void code_7()
{
	LOG("hlist[i++] = %s->hwnd;\n",var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0:code_0();break;
		case 1:code_1();break;
		case 2:code_2();break;
		case 3:code_3();break;
		case 4:code_4();break;
		case 5:code_5();break;
		case 6:code_6();break;
		case 7:code_7();break;		
	}
  return OK;
}

int before_draw()
{
	return OK;
}
int draw()
{
		
	CRect r;
	
	GetRect(&r);
	r.Normalize();
	
	DrawEditBox(&r,"Text Box(Multiple lines)");
	
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="eb_";

max_size = 0;	//0 is auto
read_only = 0;
auto_h_scroll = 0;
auto_v_scroll = 1;
h_scroll_bar = 0;
v_scroll_bar = 1;
want_return = 1;
edge_type = 1;
/*****
0 = static edge
1 = client edge
2 = normal border
*****/

]]>
</default>
</EditBox_MultiLine>
<Button isnode="true" icon="21" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *caption;
char *var;

void code_0()
{
}
void code_1()
{
	LOG("CButton *%s;\n",var);
}
void code_2()
{
	LOG("this->%s = NULL;\n",var);
}
void code_3()
{
LOG("NEW(this->%s,CButton);\r\n",var);
LOG("this->%s->Init();\r\n",var);
LOG("this->%s->SetParent(hwnd);\r\n",var);
LOG("this->%s->SetText(L\"%s\");\r\n",var,caption);
LOG("this->%s->Create();\r\n",var);
LOG("this->%s->SetStockFont(DEFAULT_GUI_FONT);\r\n",var);
}
void code_4()
{
	LOG("DEL(this->%s);\n",var);
}
void code_5()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->%s->MoveWindow(x+%d,y+%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
void code_6()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->MoveChildWindow(%s->hwnd,%d,%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
void code_7()
{
	LOG("hlist[i++] = %s->hwnd;\n",var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0:code_0();break;
		case 1:code_1();break;
		case 2:code_2();break;
		case 3:code_3();break;
		case 4:code_4();break;
		case 5:code_5();break;
		case 6:code_6();break;
		case 7:code_7();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;
	
	GetRect(&r);
	
	DrawButton(&r,caption);
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="pb_";
caption="button";

]]>
</default>
</Button>
<HScrollBar isnode="true" icon="28" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

int min,max;
int line_step,page_step;
char *var;

void code_0()
{
}
void code_1()
{
	LOG("CScrollBar *%s;\n",var);
}
void code_2()
{
	LOG("this->%s = NULL;\n",var);
}
void code_3()
{

LOG("NEW(this->%s,CScrollBar);\r\n",var);
LOG("this->%s->Init();\r\n",var);
LOG("this->%s->SetParent(hwnd);\r\n",var);
LOG("this->%s->SetDir(0);\n",var);
LOG("this->%s->SetRange(%d,%d);\n",var,min,max);
LOG("this->%s->Create();\r\n",var);
LOG("this->%s->SetLineStep(%d);\n",var,line_step);
LOG("this->%s->SetPageSize(%d);\n",var,page_step);

}
void code_4()
{
	LOG("DEL(this->%s);\n",var);
}
void code_5()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->%s->MoveWindow(x+%d,y+%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
void code_6()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->MoveChildWindow(%s->hwnd,%d,%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}

int code(int code_num)
{
	switch(code_num)
	{
		case 0:code_0();break;
		case 1:code_1();break;
		case 2:code_2();break;
		case 3:code_3();break;
		case 4:code_4();break;
		case 5:code_5();break;
		case 6:code_6();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r,rt;
	int ml,mr,hw,triw;
	
	GetRect(&r);
	r.Normalize();
	DrawHScrollBar(&r);
	return OK;
}
]]>
</code>
<default>
<![CDATA[

var = "sb_";
min = 0;
max = 100;
line_step = 1;
page_step = 10;

]]>
</default>
</HScrollBar>
<VScrollBar isnode="true" icon="28" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

int min,max;
int line_step,page_step;
char *var;

void code_0()
{
}
void code_1()
{
	LOG("CScrollBar *%s;\n",var);
}
void code_2()
{
	LOG("this->%s = NULL;\n",var);
}
void code_3()
{
LOG("NEW(this->%s,CScrollBar);\r\n",var);
LOG("this->%s->Init();\r\n",var);
LOG("this->%s->SetParent(hwnd);\r\n",var);
LOG("this->%s->SetDir(1);\n",var);
LOG("this->%s->SetRange(%d,%d);\n",var,min,max);
LOG("this->%s->Create();\r\n",var);
LOG("this->%s->SetLineStep(%d);\n",var,line_step);
LOG("this->%s->SetPageSize(%d);\n",var,page_step);

}
void code_4()
{
	LOG("DEL(this->%s);\n",var);
}
void code_5()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->%s->MoveWindow(x+%d,y+%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
void code_6()
{
	CRect r;
	GetRect(&r);
	r.Normalize();

	LOG("this->MoveChildWindow(%s->hwnd,%d,%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}

int code(int code_num)
{
	switch(code_num)
	{
		case 0:code_0();break;
		case 1:code_1();break;
		case 2:code_2();break;
		case 3:code_3();break;
		case 4:code_4();break;
		case 5:code_5();break;
		case 6:code_6();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r,rt;
	int ml,mr,hw,triw;
	
	GetRect(&r);
	r.Normalize();
	DrawVScrollBar(&r);
	return OK;
}
]]>
</code>
<default>
<![CDATA[

var = "sb_";
min = 0;
max = 100;
line_step = 1;
page_step = 10;

]]>
</default>
</VScrollBar>

<CheckBox isnode="true" icon="23" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *var;
char *caption;

void code_0()
{
}
void code_1()
{
	LOG("CCheckBox *%s;\n",var);
}
void code_2()
{
	LOG("this->%s = NULL;\n",var);
}
void code_3()
{
LOG("NEW(this->%s,CCheckBox);\r\n",var);
LOG("this->%s->Init();\r\n",var);
LOG("this->%s->SetParent(hwnd);\r\n",var);
LOG("this->%s->SetText(L\"%s\");\r\n",var,caption);
LOG("this->%s->Create();\r\n",var);
LOG("this->%s->SetStockFont(DEFAULT_GUI_FONT);\r\n",var);
}
void code_4()
{
	LOG("DEL(this->%s);\n",var);
}
void code_5()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->%s->MoveWindow(x+%d,y+%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
void code_6()
{
	CRect r;
	GetRect(&r);
	r.Normalize();

	LOG("this->MoveChildWindow(%s->hwnd,%d,%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
void code_7()
{
	LOG("hlist[i++] = %s->hwnd;\n",var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0:code_0();break;
		case 1:code_1();break;
		case 2:code_2();break;
		case 3:code_3();break;
		case 4:code_4();break;
		case 5:code_5();break;
		case 6:code_6();break;
		case 7:code_7();break;		
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
		
	CRect r,rt;
	int bs = 10;
	
	GetRect(&r);
	r.Normalize();
	
	DrawCheckBox(&r,caption);
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="ckb_";
caption = "CheckBox";

]]>
</default>
</CheckBox>
<RadioBox isnode="true" icon="14" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"
char *var;
char *caption;
int WS_GROUP = 0;

void code_0()
{
}
void code_1()
{
	LOG("CRadioBox *%s;\n",var);
}
void code_2()
{
	LOG("this->%s = NULL;\n",var);
}
void code_3()
{

LOG("NEW(this->%s,CRadioBox);\r\n",var);
LOG("this->%s->Init();\r\n",var);
LOG("this->%s->SetParent(hwnd);\r\n",var);
LOG("this->%s->SetText(L\"%s\");\r\n",var,caption);
if(WS_GROUP)
	LOG("this->%s->AddStyle(WS_GROUP);\n",var);
LOG("this->%s->Create();\r\n",var);
LOG("this->%s->SetStockFont(DEFAULT_GUI_FONT);\r\n",var);
}
void code_4()
{
	LOG("DEL(this->%s);\n",var);
}
void code_5()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->%s->MoveWindow(x+%d,y+%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
void code_6()
{
	CRect r;
	GetRect(&r);
	r.Normalize();

	LOG("this->MoveChildWindow(%s->hwnd,%d,%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
void code_7()
{
	LOG("hlist[i++] = %s->hwnd;\n",var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0:code_0();break;
		case 1:code_1();break;
		case 2:code_2();break;
		case 3:code_3();break;
		case 4:code_4();break;
		case 5:code_5();break;
		case 6:code_6();break;
		case 7:code_7();break;		
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
		
	CRect r,rt;
	int bs = 11;
	
	GetRect(&r);
	r.Normalize();
	DrawRadioBox(&r,caption);
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="rb_";
caption = "Radio";
WS_GROUP = 0;

]]>
</default>
</RadioBox>
<GroupBox isnode="true" icon="15" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"
char *caption;
char *var;

void code_0()
{
}
void code_1()
{
	LOG("CGroupBox *%s;\n",var);
}
void code_2()
{
	LOG("this->%s = NULL;\n",var);
}
void code_3()
{
LOG("NEW(this->%s,CGroupBox);\r\n",var);
LOG("this->%s->Init();\r\n",var);
LOG("this->%s->SetParent(hwnd);\r\n",var);
LOG("this->%s->SetText(L\"%s\");\r\n",var,caption);
LOG("this->%s->Create();\r\n",var);
LOG("this->%s->SetStockFont(DEFAULT_GUI_FONT);\r\n",var);
}
void code_4()
{
	LOG("DEL(this->%s);\n",var);
}
void code_5()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->%s->MoveWindow(x+%d,y+%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
void code_6()
{
	CRect r;
	GetRect(&r);
	r.Normalize();

	LOG("this->MoveChildWindow(%s->hwnd,%d,%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0:code_0();break;
		case 1:code_1();break;
		case 2:code_2();break;
		case 3:code_3();break;
		case 4:code_4();break;
		case 5:code_5();break;
		case 6:code_6();break;		
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r,rt;
	GetRect(&r);
	r.Normalize();
	
	DrawGroupBox(&r,caption);
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var = "gp_";
caption = "GroupBox";

]]>
</default>
</GroupBox>
<ListBox isnode="true" icon="17" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *var;
int view_width;

void code_0()
{
}
void code_1()
{
	LOG("CListBox *%s;\n",var);
}
void code_2()
{
	LOG("this->%s = NULL;\n",var);
}
void code_3()
{
LOG("NEW(this->%s,CListBox);\r\n",var);
LOG("this->%s->Init();\r\n",var);
LOG("this->%s->SetParent(hwnd);\r\n",var);
if(view_width > 0)
	LOG("this->%s->AddStyle(WS_HSCROLL);\r\n",var);
LOG("this->%s->Create();\r\n",var);
LOG("this->%s->SetStockFont(DEFAULT_GUI_FONT);\r\n",var);
if(view_width > 0)
	LOG("this->%s->SetViewWidth(%d);\r\n",var,view_width);

}
void code_4()
{
	LOG("DEL(this->%s);\n",var);
}
void code_5()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->%s->MoveWindow(x+%d,y+%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
void code_6()
{
	CRect r;
	GetRect(&r);
	r.Normalize();

	LOG("this->MoveChildWindow(%s->hwnd,%d,%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
void code_7()
{
	LOG("hlist[i++] = %s->hwnd;\n",var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0:code_0();break;
		case 1:code_1();break;
		case 2:code_2();break;
		case 3:code_3();break;
		case 4:code_4();break;
		case 5:code_5();break;
		case 6:code_6();break;
		case 7:code_7();break;		
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
		
	CRect r;
	
	GetRect(&r);
	r.Normalize();
	DrawListBox(&r);

	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="lb_";
view_width = 0; //0 is auto
]]>
</default>
</ListBox>
<ComboBox isnode="true" icon="18" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *var;
int dropdown_len;
int is_dropdownlist;

void code_0()
{
}
void code_1()
{
	LOG("CCombBox *%s;\n",var);
}
void code_2()
{
	LOG("this->%s = NULL;\n",var);
}
void code_3()
{
LOG("NEW(this->%s,CCombBox);\r\n",var);
LOG("this->%s->Init();\r\n",var);
LOG("this->%s->SetParent(hwnd);\r\n",var);
if(is_dropdownlist)
	LOG("this->%s->AddStyle(CBS_DROPDOWNLIST);\r\n",var);
LOG("this->%s->Create();\r\n",var);
LOG("this->%s->SetStockFont(DEFAULT_GUI_FONT);\r\n",var);

}
void code_4()
{
	LOG("DEL(this->%s);\n",var);
}
void code_5()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->%s->MoveWindow(x+%d,y+%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight()+dropdown_len);
}
void code_6()
{
	CRect r;
	GetRect(&r);
	r.Normalize();

	LOG("this->MoveChildWindow(%s->hwnd,%d,%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight()+dropdown_len);
}
void code_7()
{
	if(is_dropdownlist)
		LOG("hlist[i++] = %s->hwnd;\n",var);
	else
		LOG("hlist[i++] = %s->GetChild(0);\n",var);
}

int code(int code_num)
{
	switch(code_num)
	{
		case 0:code_0();break;
		case 1:code_1();break;
		case 2:code_2();break;
		case 3:code_3();break;
		case 4:code_4();break;
		case 5:code_5();break;
		case 6:code_6();break;
		case 7:code_7();break;		
	}
  return OK;
}
int before_draw()
{
	CRect r;
	
	GetRect(&r);
	
	if(r.GetHeight() < 0)
		r.SetHeight(-20);
	else
		r.SetHeight(20);
	
	SetRect(&r);
	
	return OK;
}
int draw()
{
	CRect r,rt;
	
	GetRect(&r);
	r.Normalize();
	
	r.bottom += dropdown_len;
	DrawComboBox(&r);
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="cb_";
dropdown_len = 100;
is_dropdownlist = 0;

]]>
</default>
</ComboBox>
<ToolBar isnode="true" icon="19" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

#define MAX_TBB 100

char *var;
int img_width,img_height;
int color_depth,img_nums;
int i = 0,img_index = 0;

char *tbb_var[MAX_TBB];
char *tbb_tooltip[MAX_TBB];
int tbb_img[MAX_TBB];
char *img_id;

COLORREF mask_color;

void code_0()
{
}
void code_1()
{
	int k;
	LOG("CToolBar *%s;\n",var);
	
	for(k = 0; k < i; k++)
	{
		if(tbb_var[k] && tbb_var[k][0])
			LOG("CTBButton *%s;\n",tbb_var[k]);
	}
}
void code_2()
{
	int k;
	
	LOG("this->%s = NULL;\n",var);

	for(k = 0; k < i; k++)
	{
		if(tbb_var[k] && tbb_var[k][0])
			LOG("this->%s = NULL;\n",tbb_var[k]);
	}
	
}
void code_3()
{
LOG("NEW(this->%s,CToolBar);\r\n",var);
LOG("this->%s->Init();\r\n",var);
LOG("this->%s->SetParent(hwnd);\r\n",var);
LOG("this->%s->Create();\r\n",var);
LOG("this->%s->CreateImageList(%s,%d,%d,%d,%d,RGB(%d,%d,%d));\n",
								var,img_id,img_width,img_height,color_depth,img_nums,
								GetRValue(mask_color),GetGValue(mask_color),GetBValue(mask_color));
LOG("this->%s->SetAutoSize();\n",var);


	int k;
	
	for(k = 0; k < i; k++)
	{
		if(tbb_var[k] && tbb_var[k][0])
		{
			LOG("NEW(this->%s,CTBButton);\n",tbb_var[k]);
			LOG("this->%s->Init();\n",tbb_var[k]);
			LOG("this->%s->SetImgIndex(%d);\n",tbb_var[k],tbb_img[k]);
			LOG("this->%s->SetToolTip(L\"%s\");\n",tbb_var[k],tbb_tooltip[k]);
		}				
	}
}

void code_4()
{
	int k;
	LOG("DEL(this->%s);\n",var);
	for(k = 0; k < i; k++)
	{
		if(tbb_var[k] && tbb_var[k][0])
			LOG("DEL(this->%s);\n",tbb_var[k]);
	}	
}
void code_5()
{
	int k;	
	for(k = 0; k < i; k++)
	{
		if(tbb_var[k] && tbb_var[k][0])
			LOG("this->%s->AddButton(%s);\n",var,tbb_var[k]);
		else
			LOG("this->%s->AddSeparator();\n",var);
			
	}	
}

int init()
{
	int k;

	for(k = 0;k<MAX_TBB;k++)
	{
		tbb_var[k] = NULL;
		tbb_tooltip[k] = NULL;
		tbb_img[k] = 0;
	}
	i = 0;	
	img_index = 0;
	_init_attrib();	
	
	return OK;
}

int code(int code_num)
{
	init();
	switch(code_num)
	{
		case 0:code_0();break;
		case 1:code_1();break;
		case 2:code_2();break;
		case 3:code_3();break;
		case 4:code_4();break;
		case 5:code_5();break;
	}
  return OK;
}
int before_draw()
{
	CRect r;
	
	GetRect(&r);
	if(r.GetHeight() < 0)
		r.SetHeight(-(img_height + 4));
	else
		r.SetHeight(img_height + 4);
	
	SetRect(&r);
	
	return OK;
}
int draw()
{
	CRect r,rt;


	GetRect(&r);
	r.Normalize();
	init();
	DrawToolBar(&r,img_index,img_width,img_height);
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="toolbar_";
img_width = 16;
img_height = 16;
color_depth = 16;
img_nums = 10;
mask_color = RGB(255,0,255);
img_id = "IDB_BITMAP1";

////////////////////////////////
//tbb_var
////////////////////////////////
tbb_var[i] = "tbb_";
tbb_tooltip[i] = "good";
tbb_img[i++] = img_index ++;


]]>
</default>
</ToolBar>
<MenuBar isnode="true" icon="33" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *var;
char *str_item[100];
int i;

void code_0()
{
}
void code_1()
{
	LOG("CMenu *%s;\n",var);
}
void code_2()
{
	int k;
	LOG("this->%s = NULL;\n",var);
}
void code_3()
{
	LOG("NEW(this->%s,CMenu);\r\n",var);
	LOG("this->%s->Init();\r\n",var);
	LOG("this->%s->Create();\r\n",var);
}
void code_4()
{
	LOG("DEL(this->%s);\n",var);

}
void code_7()
{
	LOG("this->CreateRpCommandBar(%s);\n",var);
}
void init()
{
	i = 0;
	_init_attrib();
}

int code(int code_num)
{
	init();
	switch(code_num)
	{
		case 0:code_0();break;
		case 1:code_1();break;
		case 2:code_2();break;
		case 3:code_3();break;
		case 4:code_4();break;
		case 7:code_7();break;
	}
  return OK;
}
int before_draw()
{
	CRect r;
	
	GetRect(&r);
	
	if(r.GetHeight() < 0)
		r.SetHeight(-16);
	else
		r.SetHeight(16);
	
	SetRect(&r);
	
	return OK;
}
int draw()
{
	CRect r,rt;
	
	GetRect(&r);
	r.Normalize();
	init();
	
	str_item[i++] = "File";
	str_item[i++] = "Edit";
	str_item[i++] = "Help";
	
	DrawMenuBar(&r,str_item,i);
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="menu_bar";
]]>
</default>
</MenuBar>
<Menu isnode="true" icon="32" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *var;
char *name;
char *var_item[100];
char *str_item[100];
int i,is_pop;

void code_0()
{
}
void code_1()
{
	int k;
	if(is_pop)
		LOG("CPopupMenu *%s;\n",var);
	else
		LOG("CMenu *%s;\n",var);
		
	for(k = 0; k < 100; k++)
	{
		if(var_item[k])
			LOG("CMenu *%s;\n",var_item[k]);
	}
}
void code_2()
{
	int k;
	LOG("this->%s = NULL;\n",var);
	for(k = 0; k < 100; k++)
	{
		if(var_item[k])
			LOG("this->%s = NULL;\n",var_item[k]);
	}
}
void code_3()
{
	if(is_pop)
	{
		LOG("NEW(this->%s,CPopupMenu);\r\n",var);
		LOG("this->%s->SetParent(hwnd);\n",var);
	}
	else
	{
		LOG("NEW(this->%s,CMenu);\r\n",var);
	}
	LOG("this->%s->Init();\r\n",var);
	LOG("this->%s->SetName(L\"%s\");\n",var,name);
	LOG("this->%s->Create();\r\n",var);

	int k;
	
	for(k = 0; k < 100; k++)
	{
		if(var_item[k])
		{
			LOG("NEW(this->%s,CMenu);\n",var_item[k]);
			LOG("this->%s->Init();\r\n",var_item[k]);
			LOG("this->%s->SetName(L\"%s\");\n",var_item[k],str_item[k]);
			LOG("this->%s->Create();\r\n",var_item[k]);
		}
	}
	
}
void code_4()
{
	LOG("DEL(this->%s);\n",var);
	int k;
	
	for(k = 0; k < 100; k++)
	{
		if(var_item[k])
		{
			LOG("DEL(this->%s);\n",var_item[k]);
		}
	}	
}
void code_7()
{
	int k;
	LOG("this->menu_bar->AddMenu(%s);\n",var);

	for(k = 0; k < 100; k++)
	{
		if(var_item[k])
		{
			LOG("this->%s->AddItem(%s);\r\n",var,var_item[k]);
		}
		else if(str_item[k] && str_item[k][0] == '-')
		{
			LOG("this->%s->AddSeparator();\n",var);
		}
	}
}


void init()
{
	for(i = 0; i < 100; i++)
	{
		var_item[i] = NULL;
		str_item[i] = NULL;
	}
	
	i = 0;
	_init_attrib();
}

int code(int code_num)
{
	init();
	switch(code_num)
	{
		case 0:code_0();break;
		case 1:code_1();break;
		case 2:code_2();break;
		case 3:code_3();break;
		case 4:code_4();break;
		case 7:code_7();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r,rt;
	
	GetRect(&r);
	r.Normalize();
	init();
	DrawMenuWnd(&r,str_item,i);
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="menu_";
name = "File";
is_pop = 0;	//

var_item[i] = "mitem_1";
str_item[i++] = "item1";

str_item[i++] = "---";

var_item[i] = "mitem_2";
str_item[i++] = "item2";

]]>
</default>
</Menu>
<ListView isnode="true" icon="29" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

#define MAX_COLUMN 256

int i;
char *var;
int column_width[MAX_COLUMN];
char* column_text[MAX_COLUMN];
int full_selected;
int grid_view;
int check_box;

COLORREF mask_color;

void code_0()
{
}
void code_1()
{
	int k;
	LOG("CListView *%s;\n",var);
}
void code_2()
{
	LOG("this->%s = NULL;\n",var);
}
void code_3()
{
	LOG("NEW(this->%s,CListView);\r\n",var);
	LOG("this->%s->Init();\r\n",var);
	LOG("this->%s->SetParent(hwnd);\r\n",var);
	LOG("this->%s->Create();\r\n",var);
	
	CMem mem;
	LOCAL_MEM(mem);
	
	if(full_selected)
		mem.Puts("LVS_EX_FULLROWSELECT|");
	if(check_box)
		mem.Puts("LVS_EX_CHECKBOXES|");
	if(grid_view)
		mem.Puts("LVS_EX_GRIDLINES|");
	
	if(mem.GetSize() > 0)
	{
		mem.SetChar(mem.GetSize() - 1, 0);
		LOG("this->%s->SetListViewExStyle(%s);\n",var,mem.p);
	}
	
	int k = 0;
	
	while(column_text[k])
	{
		LOG("this->%s->AddColumn(L\"%s\",%d);\n",var,column_text[k],column_width[k]);
		k++;
	}
	
	
}

void code_4()
{
	LOG("DEL(this->%s);\n",var);
}
void code_5()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	LOG("this->%s->MoveWindow(x+%d,y+%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
}
void code_6()
{
	CRect r;
	GetRect(&r);
	r.Normalize();

	LOG("this->MoveChildWindow(%s->hwnd,%d,%d,%d,%d);\r\n",var,r.left,r.top,r.GetWidth(),r.GetHeight());
	LOG("this->%s->OnSize();\n",var);
}


int init()
{
	int k;

	for(k = 0;k<MAX_COLUMN;k++)
	{
		column_width[k] = 0;
		column_text[k] = 0;
	}
	i = 0;	

	_init_attrib();	
	
	return OK;
}

int code(int code_num)
{
	init();
	switch(code_num)
	{
		case 0:code_0();break;
		case 1:code_1();break;
		case 2:code_2();break;
		case 3:code_3();break;
		case 4:code_4();break;
		case 5:code_5();break;
		case 6:code_6();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r,rt;


	GetRect(&r);
	r.Normalize();
	init();
	
	DrawListView(&r,column_width,column_text);
	
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="listview_";

full_selected = 1;
grid_view = 0;
check_box = 0;

column_text[i] = "column1";
column_width[i++] = 50;

column_text[i] = "column2";
column_width[i++] = 50;

]]>
</default>
</ListView>
</Controls>
<Windows isnode="true" icon="2">
<Window isnode="true">
<code>
<![CDATA[
char *var,*caption,*parent;
char *class_name;
int on_msg[100];
int generate_code;

void on_msg_code_header()
{
	if(on_msg[0])printf("    int OnCreate(WPARAM wparam, LPARAM lparam);\n");
	if(on_msg[1])printf("    int OnClose(WPARAM wparam, LPARAM lparam);\n");
	if(on_msg[2])printf("    int OnPaint(WPARAM wparam, LPARAM lparam);\n");
	if(on_msg[3])printf("    int OnSize(WPARAM wparam, LPARAM lparam);\n");
	if(on_msg[4])printf("    int OnCommand(WPARAM wparam, LPARAM lparam);\n");
	if(on_msg[5])printf("    int OnNotify(WPARAM wparam, LPARAM lparam);\n");
	if(on_msg[6])printf("    int OnLButtonDown(WPARAM wparam, LPARAM lparam);\n");
	if(on_msg[7])printf("    int OnLButtonUp(WPARAM wparam, LPARAM lparam);\n");
	if(on_msg[8])printf("    int OnRButtonDown(WPARAM wparam, LPARAM lparam);\n");
	if(on_msg[9])printf("    int OnRButtonUp(WPARAM wparam, LPARAM lparam);\n");
	if(on_msg[10])printf("    int OnScroll(WPARAM wparam, LPARAM lparam);\n");
	if(on_msg[11])printf("    int OnMouseMove(WPARAM wparam, LPARAM lparam);\n");
	if(on_msg[12])printf("    int OnChar(WPARAM wparam, LPARAM lparam);\n");
	if(on_msg[13])printf("    int OnKeyDown(WPARAM wparam, LPARAM lparam);\n");
	if(on_msg[14])printf("    int OnPosChanged(WPARAM wparam, LPARAM lparam);\n");	
	if(on_msg[15])printf("    int OnUserWndRet(WPARAM wparam, LPARAM lparam);\n");	
	LOG("    int PreTransMsg(MSG *msg);\r\n");
}

void on_msg_code_body()
{
	CRect r;
	
	GetRect(&r);
	r.Normalize();
	
	if(on_msg[0])
	{
		printf("int %s::OnCreate(WPARAM wparam, LPARAM lparam)\n",class_name);
		printf("{\n");
		printf("\tthis->SetVirtualSize(%d,%d);\n",r.GetWidth(),r.GetHeight());
		printf("\tthis->OnSize(0,0);\n");
		printf("\treturn OK;\n");
		printf("}\n");
	}
	
	if(on_msg[1])printf("int %s::OnClose(WPARAM wparam, LPARAM lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[2])printf("int %s::OnPaint(WPARAM wparam, LPARAM lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[3])printf("int %s::OnSize(WPARAM wparam, LPARAM lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[4])printf("int %s::OnCommand(WPARAM wparam, LPARAM lparam)\n{\n    return OK;\n}\n",class_name);				
	if(on_msg[5])printf("int %s::OnNotify(WPARAM wparam, LPARAM lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[6])printf("int %s::OnLButtonDown(WPARAM wparam, LPARAM lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[7])printf("int %s::OnLButtonUp(WPARAM wparam, LPARAM lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[8])printf("int %s::OnRButtonDown(WPARAM wparam, LPARAM lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[9])printf("int %s::OnRButtonUp(WPARAM wparam, LPARAM lparam)\n{\n    return OK;\n}\n",class_name);				
	if(on_msg[10])printf("int %s::OnScroll(WPARAM wparam, LPARAM lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[11])printf("int %s::OnMouseMove(WPARAM wparam, LPARAM lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[12])printf("int %s::OnChar(WPARAM wparam, LPARAM lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[13])printf("int %s::OnKeyDown(WPARAM wparam, LPARAM lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[14])printf("int %s::OnPosChanged(WPARAM wparam, LPARAM lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[15])printf("int %s::OnUserWndRet(WPARAM wparam, LPARAM lparam)\n{\n    return OK;\n}\n",class_name);
	
	LOG("int %s::PreTransMsg(MSG *msg)\r\n",class_name);
	LOG("{\r\n");
	LOG("\tHWND hlist[100];\r\n");
	LOG("\r\n");
	LOG("\tint i = 0;\r\n");
	LOG("\r\n");
	LOG("\treturn this->TabFocus(hlist,i,msg);\r\n");
	LOG("}\r\n");

}
void code_0()
{
	printf("#include \"wnd.h\"\n\n");
	printf("class %s:public CWnd{\n",class_name);
	printf("public:\n");
	printf("public:\n");
	printf("    %s();\n",class_name);
	printf("    virtual ~%s();\n",class_name);
	printf("    int Init();\n");
	printf("    int Destroy();\n");
	printf("    int InitBasic();\n");
	on_msg_code_header();
	printf("};\n\n");
	printf("%s::%s()\n",class_name,class_name);
	printf("{\n");
	printf("    this->InitBasic();\n");
	printf("}\n");
	printf("%s::~%s()\n",class_name,class_name);
	printf("{\n");
	printf("    this->Destroy();\n");
	printf("}\n");
	printf("int %s::InitBasic()\n",class_name);
	printf("{\n");
	printf("    CWnd::InitBasic();\n");
	printf("    return OK;\n");
	printf("}\n");
	printf("int %s::Init()\n",class_name);
	printf("{\n");
	printf("    this->InitBasic();\n");
	printf("    CWnd::Init();\n");
	printf("    //add your code\n");
	printf("    return OK;\n");
	printf("}\n");
	printf("int  %s::Destroy()\n",class_name);
	printf("{\n");
	printf("    //add your code\n");
	printf("    CWnd::Destroy();\n");
	printf("    this->InitBasic();\n");
	printf("    return OK;\n");
	printf("}\n");

	on_msg_code_body();	
}
void code_1()
{
	printf("\n%s *%s;\n",class_name,var);
}
void code_2()
{
	LOG("%s = NULL;\n",var);
}
void code_3()
{
	CRect r;
	
	GetRect(&r);
	r.Normalize();
	

  printf("NEW(%s,%s);\n",var,class_name);
  printf("%s->Init();\n",var);
  printf("%s->MoveWindow(0,0,%d,%d);\n",var,r.GetWidth(),r.GetHeight());
  printf("%s->SetText(L\"%s\");\n",var,caption);
  printf("%s->SetParent(%s);\n",var,parent);
  printf("%s->Create();\n",var);
}
void code_4()
{
	LOG("DEL(%s);\n",var);
}
int code(int code_num)
{
	if(!generate_code)
		return ERROR;
	switch(code_num)
	{
		case 0: code_0();break;
		case 1: code_1();break;
		case 2: code_2();break;
		case 3: code_3();break;
		case 4: code_4();break;
	}
  return OK;
}
int before_draw()
{
	CRect r;
	
	GetRect(&r);
	r.Normalize();
	
	r.right -= r.left;
	r.bottom -= r.top;
	r.left = 0;
	r.top = 0;
	
	SetRect(&r);
	
	return OK;
}
int draw()
{
		
	CRect r;
	
	GetRect(&r);
	r.Normalize();
	
	Draw3DFrame(FRAME3D_UP,&r);

	return OK;
}
]]>
</code>
<default>
<![CDATA[
class_name="CWnd";
var = "wnd_";
caption = "Hello";
parent="hwnd";
generate_code = 1;

/***messages need to response***/
on_msg[0]=1;    //WM_CREATE
on_msg[1]=1;    //WM_CLOSE
on_msg[2]=0;    //WM_PAINT
on_msg[3]=1;    //WM_SIZE
on_msg[4]=1;    //WM_COMMAND
on_msg[5]=0;    //WM_NOTIFY
on_msg[6]=0;    //WM_LBUTTONDOWN
on_msg[7]=0;    //WM_LBUTTONUP
on_msg[8]=0;    //WM_RBUTTONDOWN
on_msg[9]=0;    //WM_RBUTTONUP
on_msg[10]=0;   //WM_HSCROLL & WM_VSCROLL
on_msg[11]=0;   //WM_MOUSEMOVE
on_msg[12]=0;   //WM_CHAR
on_msg[13]=0;   //WM_KEYDOWN
on_msg[14]=0;   //WM_WINDOWPOSCHANGED
on_msg[15]=0;	//WM_WND_USER_RET
]]>
</default>
</Window>

</Windows>
<Math isnode="true" icon="15">
<FunctionCurve isnode="true">
<code>
<![CDATA[
float x,y;
int zoom_in_x;
int zoom_in_y;
float step,start_x,end_x;

#define FUNC(a,b) {x=a;_init_attrib();b=y;}

int code(int code_num)
{
  return OK;
}

int SetPixel(CRect *r,float x,float y)
{
	int x0 = r->left + r->GetWidth()/2;
	int y0 = r->top + r->GetHeight()/2;
	
	SetPixel(x0 + (int)(x * (float)zoom_in_x),y0 - (int)(y * (float)zoom_in_y),RGB(255,0,0));
	
	return OK;
}
int DrawAxis(CRect *r)
{
	SetPen(PS_SOLID,0,RGB(0,0,255));
	DrawLine(r->left,r->top + r->GetHeight()/2,r->right,r->top + r->GetHeight()/2);
	DrawLine(r->left + r->GetWidth()/2,r->top,r->left + r->GetWidth()/2,r->bottom);
	return OK;
}
int DrawCurve(CRect *r)
{
	float yy;
	
	int x0 = r->left + r->GetWidth()/2;
	int y0 = r->top + r->GetHeight()/2;
	
	float m_start = (float)(r->left - x0) / zoom_in_x;
	float m_end = (float)(r->right - x0) / zoom_in_x;
	
	float x1,x2;
	
	x1 = start_x;
	x2 = end_x;
	
	if(start_x < m_start)
		x1 = m_start;
	if(end_x > m_end)
		x2 = m_end;

	for(float i = x1; i<= x2; i+= step)
	{
		FUNC(i,yy);
		SetPixel(r,i,yy);
	}
	return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	
	DrawAxis(&r);
	DrawCurve(&r);
	
	return OK;
}
]]>
</code>
<default>
<![CDATA[
//this is the function you will draw
y = sin(x); 

zoom_in_x = 20;
zoom_in_y = 20;
step = 0.05;
start_x = -9999.0;
end_x = 9999.0;

]]>
</default>
</FunctionCurve>
<Calculator isnode="true">
<code>
<![CDATA[
double x;

int code(int code_num)
{
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	
	_init_attrib(); //calculate;
	
	char buf[1024];
	sprintf(buf,"x = %f",x);
	
	SetTextColor(RGB(255,0,0));
	SetBkMode(TRANSPARENT);
	SetStockFont(DEFAULT_GUI_FONT);
	DrawText(buf,&r,DT_CENTER|DT_VCENTER|DT_SINGLELINE);
	
	return OK;
}

]]>
</code>
<default>
<![CDATA[
//write your expression
x = sin(1.2);
]]>
</default>
</Calculator>
</Math>
<moonGUI isnode="true" icon="25">
<Window isnode="true" icon="2" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"
char *caption,*style,*ex_style;
char *var,*class_name;
int on_msg[100];

void on_msg_code_header()
{
	if(on_msg[0])printf("    int OnCreate(int wparam, int lparam);\n");
	if(on_msg[1])printf("    int OnClose(int wparam, int lparam);\n");
	if(on_msg[2])printf("    int OnPaint(int wparam, int lparam);\n");
	if(on_msg[3])printf("    int OnCommand(int wparam, int lparam);\n");
	if(on_msg[4])printf("    int OnLButtonDown(int wparam, int lparam);\n");
	if(on_msg[5])printf("    int OnLButtonUp(int wparam, int lparam);\n");
	if(on_msg[6])printf("    int OnRButtonDown(int wparam, int lparam);\n");
	if(on_msg[7])printf("    int OnRButtonUp(int wparam, int lparam);\n");
	if(on_msg[8])printf("    int OnMouseMove(int wparam, int lparam);\n");
	if(on_msg[9])printf("    int OnChar(int wparam, int lparam);\n");
	if(on_msg[10])printf("    int OnKeyDown(int wparam, int lparam);\n");
	if(on_msg[11])printf("    int OnPosChanged(int wparam, int lparam);\n");	
	if(on_msg[12])printf("    int OnUnknown(u32 message,int wparam, int lparam);\n");	
}

void on_msg_code_body()
{
	if(on_msg[0])printf("int %s::OnCreate(int wparam, int lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[1])
	{	
		printf("int %s::OnClose(int wparam, int lparam)\n",class_name);
		printf("{\n\tCWindow::OnClose(wparam,lparam);\n\treturn OK;\n}\n");
	}
	if(on_msg[2])
	{
		printf("int %s::OnPaint(int wparam, int lparam)\n",class_name);
		printf("{\n\tthis->BeginPaint(lparam);\n\tthis->EndPaint();\n\treturn OK;\n}\n");
	}
	if(on_msg[3])printf("int %s::OnCommand(int wparam, int lparam)\n{\n    return OK;\n}\n",class_name);				
	if(on_msg[4])printf("int %s::OnLButtonDown(int wparam, int lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[5])printf("int %s::OnLButtonUp(int wparam, int lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[6])printf("int %s::OnRButtonDown(int wparam, int lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[7])printf("int %s::OnRButtonUp(int wparam, int lparam)\n{\n    return OK;\n}\n",class_name);				
	if(on_msg[8])printf("int %s::OnMouseMove(int wparam, int lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[9])printf("int %s::OnChar(int wparam, int lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[10])printf("int %s::OnKeyDown(int wparam, int lparam)\n{\n    return OK;\n}\n",class_name);
	if(on_msg[11])printf("int %s::OnPosChanged(int wparam, int lparam)\n{\n    return OK;\n}\n",class_name);				
	if(on_msg[12])
	{
		printf("int %s::OnUnknown(u32 message,int wparam, int lparam)\n",class_name);
		printf("{\n\treturn OK;\n}\n");
	}
}
void code_0()
{
	printf("#include \"moongui.h\"\n\n");
	printf("class %s:public CWindow{\n",class_name);
	printf("public:\n");
	printf("public:\n");
	printf("    %s();\n",class_name);
	printf("    virtual ~%s();\n",class_name);
	printf("    int Init();\n");
	printf("    int Destroy();\n");
	printf("    int InitBasic();\n");
	on_msg_code_header();
	printf("};\n");
}
void code_1()
{
	printf("%s::%s()\n",class_name,class_name);
	printf("{\n");
	printf("    this->InitBasic();\n");
	printf("}\n");
	printf("%s::~%s()\n",class_name,class_name);
	printf("{\n");
	printf("    this->Destroy();\n");
	printf("}\n");
	printf("int %s::InitBasic()\n",class_name);
	printf("{\n");
	printf("    CWindow::InitBasic();\n");
	printf("    return OK;\n");
	printf("}\n");
	printf("int %s::Init()\n",class_name);
	printf("{\n");
	printf("    this->InitBasic();\n");
	printf("    CWindow::Init();\n");
	printf("    //add your code\n");
	printf("    return OK;\n");
	printf("}\n");
	printf("int  %s::Destroy()\n",class_name);
	printf("{\n");
	printf("    //add your code\n");
	printf("    CWindow::Destroy();\n");
	printf("    this->InitBasic();\n");
	printf("    return OK;\n");
	printf("}\n");

	on_msg_code_body();
}

void code_3()
{
	CRect r;
	
	GetRect(&r);
	r.Normalize();
	
  printf("\nNEW(%s,%s);\n",var,class_name);
  printf("%s->Init();\n",var);
  printf("%s->SetRect(0,0,%d,%d);\n",var,r.GetWidth(),r.GetHeight());
  printf("%s->SetCaption(\"%s\");\n",var,caption);
 	printf("%s->dwStyle = %s;\n",var,style);
	printf("%s->dwExStyle = %s;\n",var,ex_style);

  printf("afx.wndmgr->AddWindow(%s);\n",var);
}
void code_2()
{
	printf("%s *%s;\n",class_name,var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0: code_0();break;
		case 1: code_1();break;
		case 2: code_2();break;
		case 3: code_3();break;
	}
  return OK;
}
int before_draw()
{
	CRect r;
	
	GetRect(&r);
	r.Normalize();
	
	r.right -= r.left;
	r.bottom -= r.top;
	r.left = 0;
	r.top = 0;
	
	SetRect(&r);
	
	return OK;
}
int draw()
{
	CRect rc;
	
	GetRect(&rc);
	DrawWindow(&rc,15,caption);
	
	return OK;
}

]]>
</code>
<default>
<![CDATA[
class_name="CWnd";
var="wnd_";
caption="window";
style="WS_CAPTION|WS_VISIBLE|WS_BORDER|WS_APPWND";
ex_style="0";

/***messages need to response***/
on_msg[0]=1;    //WM_CREATE
on_msg[1]=0;    //WM_CLOSE
on_msg[2]=0;    //WM_PAINT
on_msg[3]=1;    //WM_COMMAND
on_msg[4]=0;    //WM_LBUTTONDOWN
on_msg[5]=0;    //WM_LBUTTONUP
on_msg[6]=0;    //WM_RBUTTONDOWN
on_msg[7]=0;    //WM_RBUTTONUP
on_msg[8]=0;   //WM_MOUSEMOVE
on_msg[9]=0;   //WM_CHAR
on_msg[10]=0;   //WM_KEYDOWN
on_msg[11]=0;   //WM_WINDOWPOSCHANGED
on_msg[12]=0;   //WM_UNKNOWN
]]>
</default>
</Window>
<Button isnode="true" icon="21" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *caption;
char *var;

void code_0()
{
}
void code_1()
{
}
void code_2()
{
	LOG("CButton *%s;\n",var);
}
void code_3()
{
	CRect rc;
	
	GetRect(&rc);
	rc.Normalize();
	
	LOG("\nNEW(this->%s,CButton);\n",var);
	LOG("this->%s->Init();\n",var);
	LOG("this->%s->SetText(\"%s\");\n",var,caption);
	LOG("this->%s->SetRect(%d,%d,%d,%d);\n",var,rc.left,rc.top,rc.GetWidth(),rc.GetHeight());
}
void code_4()
{
	LOG("this->AddControl(this->%s);\n",var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0: code_0();break;
		case 1: code_1();break;
		case 2: code_2();break;
		case 3: code_3();break;
		case 4: code_4();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;
	
	GetRect(&r);
	
	DrawButton(&r,caption);
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="btn_";
caption="button";
]]>
</default>
</Button>
<Static isnode="true" icon="22" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *caption;
char *var;
int align;

void code_0()
{
}
void code_1()
{
}
void code_2()
{
	LOG("CStatic *%s;\n",var);
}
void code_3()
{
	CRect rc;
	
	GetRect(&rc);
	rc.Normalize();
	
	LOG("\nNEW(this->%s,CStatic);\n",var);
	LOG("this->%s->Init();\n",var);
	LOG("this->%s->SetText(\"%s\");\n",var,caption);
	LOG("this->%s->SetRect(%d,%d,%d,%d);\n",var,rc.left,rc.top,rc.GetWidth(),rc.GetHeight());
	if(align == 1)	LOG("this->%s->SetStyle(SS_LEFT);\n",var);
	if(align == 2)	LOG("this->%s->SetStyle(SS_RIGHT);\n",var);
		
}
void code_4()
{
	LOG("this->AddControl(this->%s);\n",var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0: code_0();break;
		case 1: code_1();break;
		case 2: code_2();break;
		case 3: code_3();break;
		case 4: code_4();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;
	
	GetRect(&r);
	
	DrawStatic(&r,caption,align);
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="st_";
caption="static";
align=1;
/*******
align
1 = LEFT
2 = RIGHT
*******/

]]>
</default>
</Static>
<GroupBox isnode="true" icon="23" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *caption;
char *var;

void code_0()
{
}
void code_1()
{
}
void code_2()
{
	LOG("CGroupBox *%s;\n",var);
}
void code_3()
{
	CRect rc;
	
	GetRect(&rc);
	rc.Normalize();
	
	LOG("\nNEW(this->%s,CGroupBox);\n",var);
	LOG("this->%s->Init();\n",var);
	if(caption[0])
		LOG("this->%s->SetText(\"%s\");\n",var,caption);
	else
		LOG("this->%s->SetText(NULL);\n",var);
	LOG("this->%s->SetRect(%d,%d,%d,%d);\n",var,rc.left,rc.top,rc.GetWidth(),rc.GetHeight());
	
}
void code_4()
{
	LOG("this->AddControl(this->%s);\n",var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0: code_0();break;
		case 1: code_1();break;
		case 2: code_2();break;
		case 3: code_3();break;
		case 4: code_4();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;
	
	GetRect(&r);
	
	DrawGroupBox(&r,caption);
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="gb_";
caption="";
]]>
</default>
</GroupBox>
<CheckBox isnode="true" icon="24" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *caption;
char *var;

void code_0()
{
}
void code_1()
{
}
void code_2()
{
	LOG("CCheckBox *%s;\n",var);
}
void code_3()
{
	CRect rc;
	
	GetRect(&rc);
	rc.Normalize();
	
	LOG("\nNEW(this->%s,CCheckBox);\n",var);
	LOG("this->%s->Init();\n",var);
	LOG("this->%s->SetText(\"%s\");\n",var,caption);
	LOG("this->%s->SetRect(%d,%d,%d,%d);\n",var,rc.left,rc.top,rc.GetWidth(),rc.GetHeight());
	
}
void code_4()
{
	LOG("this->AddControl(this->%s);\n",var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0: code_0();break;
		case 1: code_1();break;
		case 2: code_2();break;
		case 3: code_3();break;
		case 4: code_4();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;
	
	GetRect(&r);
	
	DrawCheckBox(&r,caption);
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="ckb_";
caption="checkbox";
]]>
</default>
</CheckBox>
<RadioBox isnode="true" icon="26" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *caption;
char *var;

void code_0()
{
}
void code_1()
{
}
void code_2()
{
	LOG("CRadioBox *%s;\n",var);
}
void code_3()
{
	CRect rc;
	
	GetRect(&rc);
	rc.Normalize();
	
	LOG("\nNEW(this->%s,CRadioBox);\n",var);
	LOG("this->%s->Init();\n",var);
	LOG("this->%s->SetText(\"%s\");\n",var,caption);
	LOG("this->%s->SetRect(%d,%d,%d,%d);\n",var,rc.left,rc.top,rc.GetWidth(),rc.GetHeight());
	
}
void code_4()
{
	LOG("this->AddControl(this->%s);\n",var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0: code_0();break;
		case 1: code_1();break;
		case 2: code_2();break;
		case 3: code_3();break;
		case 4: code_4();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;
	
	GetRect(&r);
	
	DrawRadioBox(&r,caption);
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="rb_";
caption="radio";
]]>
</default>
</RadioBox>
<HScrollBar isnode="true" icon="27" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *var;

int min,max,line_step,page_step;

void code_0()
{
}
void code_1()
{
}
void code_2()
{
	LOG("CScrollBar *%s;\n",var);
}
void code_3()
{
	CRect rc;
	
	GetRect(&rc);
	rc.Normalize();
	
	LOG("\nNEW(this->%s,CScrollBar);\n",var);
	LOG("this->%s->Init();\n",var);
	LOG("this->%s->SetRect(%d,%d,%d,%d);\n",var,rc.left,rc.top,rc.GetWidth(),rc.GetHeight());
	LOG("this->%s->SetDir(SBS_HORZ);\n",var);
	LOG("this->%s->SetMinMax(%d,%d);\n",var,min,max);
	LOG("this->%s->SetLineStep(%d);\n",var,line_step);
	LOG("this->%s->SetPageStep(%d);\n",var,page_step);
	LOG("this->%s->SetPageSize(%d);\n",var,page_step);
}
void code_4()
{
	LOG("this->AddControl(this->%s);\n",var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0: code_0();break;
		case 1: code_1();break;
		case 2: code_2();break;
		case 3: code_3();break;
		case 4: code_4();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;
	
	GetRect(&r);
	
	DrawHScrollBar(&r);
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="sb_";
min=0;
max=99;
line_step = 1;
page_step = 10;

]]>
</default>
</HScrollBar>
<VScrollBar isnode="true" icon="28" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *var;

int min,max,line_step,page_step;

void code_0()
{
}
void code_1()
{
}
void code_2()
{
	LOG("CScrollBar *%s;\n",var);
}
void code_3()
{
	CRect rc;
	
	GetRect(&rc);
	rc.Normalize();
	
	LOG("\nNEW(this->%s,CScrollBar);\n",var);
	LOG("this->%s->Init();\n",var);
	LOG("this->%s->SetRect(%d,%d,%d,%d);\n",var,rc.left,rc.top,rc.GetWidth(),rc.GetHeight());
	LOG("this->%s->SetDir(SBS_VERT);\n",var);
	LOG("this->%s->SetMinMax(%d,%d);\n",var,min,max);
	LOG("this->%s->SetLineStep(%d);\n",var,line_step);
	LOG("this->%s->SetPageStep(%d);\n",var,page_step);
	LOG("this->%s->SetPageSize(%d);\n",var,page_step);
}
void code_4()
{
	LOG("this->AddControl(this->%s);\n",var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0: code_0();break;
		case 1: code_1();break;
		case 2: code_2();break;
		case 3: code_3();break;
		case 4: code_4();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;
	
	GetRect(&r);
	
	DrawVScrollBar(&r);
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="sb_";
min=0;
max=99;
line_step = 1;
page_step = 10;

]]>
</default>
</VScrollBar>
<ListBox isnode="true" icon="29" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *var;
char *style;

void code_0()
{
}
void code_1()
{
}
void code_2()
{
	LOG("CListBox *%s;\n",var);
}
void code_3()
{
	CRect rc;
	
	GetRect(&rc);
	rc.Normalize();
	
	LOG("\nNEW(this->%s,CListBox);\n",var);
	LOG("this->%s->Init();\n",var);
	LOG("this->%s->SetRect(%d,%d,%d,%d);\n",var,rc.left,rc.top,rc.GetWidth(),rc.GetHeight());
	LOG("this->%s->SetStyle(%s);\n",var,style);
	
}
void code_4()
{
	LOG("this->AddControl(this->%s);\n",var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0: code_0();break;
		case 1: code_1();break;
		case 2: code_2();break;
		case 3: code_3();break;
		case 4: code_4();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;
	
	GetRect(&r);
	
	DrawListBox(&r);
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="lb_";
style="WS_BORDER|WS_VSCROLL";
]]>
</default>
</ListBox>
<ComboBox isnode="true" icon="3" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *var;
char *style;

void code_0()
{
}
void code_1()
{
}
void code_2()
{
	LOG("CComboBox *%s;\n",var);
}
void code_3()
{
	CRect rc;
	
	GetRect(&rc);
	rc.Normalize();
	
	LOG("\nNEW(this->%s,CComboBox);\n",var);
	LOG("this->%s->Init();\n",var);
	LOG("this->%s->SetRect(%d,%d,%d,%d);\n",var,rc.left,rc.top,rc.GetWidth(),rc.GetHeight());
}
void code_4()
{
	LOG("this->AddControl(this->%s);\n",var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0: code_0();break;
		case 1: code_1();break;
		case 2: code_2();break;
		case 3: code_3();break;
		case 4: code_4();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;
	
	GetRect(&r);
	
	DrawComboBox(&r);
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="cb_";

]]>
</default>
</ComboBox>
<EditBox isnode="true" icon="4" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *var;
char *style,*textfile;

void code_0()
{
}
void code_1()
{
}
void code_2()
{
	LOG("CEditBox *%s;\n",var);
}
void code_3()
{
	CRect rc;
	
	GetRect(&rc);
	rc.Normalize();
	
	LOG("\nNEW(this->%s,CEditBox);\n",var);
	LOG("this->%s->Init();\n",var);
	LOG("this->%s->SetStyle(%s);\n",var,style);	
	LOG("this->%s->SetRect(%d,%d,%d,%d);\n",var,rc.left,rc.top,rc.GetWidth(),rc.GetHeight());
	if(textfile[0])
		LOG("this->%s->SetTextFile(%s);\n",var,textfile);
}
void code_4()
{
	LOG("this->AddControl(this->%s);\n",var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0: code_0();break;
		case 1: code_1();break;
		case 2: code_2();break;
		case 3: code_3();break;
		case 4: code_4();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;
	
	GetRect(&r);
	
	DrawEditBox(&r,"Edit Box");
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="eb_";
style="WS_BORDER|WS_VSCROLL";
textfile="";

]]>
</default>
</EditBox>
<LineEditBox isnode="true" icon="30" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *var;
char *style,*text;

void code_0()
{
}
void code_1()
{
}
void code_2()
{
	LOG("CLineEditor *%s;\n",var);
}
void code_3()
{
	CRect rc;
	
	GetRect(&rc);
	rc.Normalize();
	
	LOG("\nNEW(this->%s,CLineEditor);\n",var);
	LOG("this->%s->Init();\n",var);
	LOG("this->%s->SetRect(%d,%d,%d,%d);\n",var,rc.left,rc.top,rc.GetWidth(),rc.GetHeight());
	LOG("this->%s->SetStyle(%s);\n",var,style);
	LOG("this->%s->SetText(\"%s\");\n",var,text);	
}
void code_4()
{
	LOG("this->AddControl(this->%s);\n",var);
}
int code(int code_num)
{
	switch(code_num)
	{
		case 0: code_0();break;
		case 1: code_1();break;
		case 2: code_2();break;
		case 3: code_3();break;
		case 4: code_4();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;
	
	GetRect(&r);
	
	DrawEditBox(&r,"Line Editor");
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="leb_";
style="WS_STATICEDGE";
text="";

]]>
</default>
</LineEditBox>
<MenuBar isnode="true" icon="31" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *var;
char *item[100];
int i;

void init()
{
	int j;
	
	for(j = 0; j < 100; j++)
	{
		item[j] = NULL;
	}
	
	i = 0;
	_init_attrib();
}
void code_0()
{
}
void code_1()
{
}
void code_2()
{
	LOG("CMenuBar *%s;\n",var);
}
void code_3()
{
	CRect rc;
	
	GetRect(&rc);
	rc.Normalize();
	
	LOG("\nNEW(this->%s,CMenuBar);\n",var);
	LOG("this->%s->Init();\n",var);
	LOG("this->%s->SetRect(%d,%d,%d,%d);\n",var,rc.left,rc.top,rc.GetWidth(),rc.GetHeight());
}
void code_4()
{
	for(int j = 0; j < 100; j++)
	{
		if(item[j])
		{
			LOG("this->%s->AddMenuBarItem(\"%s\",0);\n",var,item[j]);
		}
	}
	LOG("this->AddControl(this->%s);\n",var);
}
int code(int code_num)
{
	
	init();
	switch(code_num)
	{
		case 0: code_0();break;
		case 1: code_1();break;
		case 2: code_2();break;
		case 3: code_3();break;
		case 4: code_4();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	init();
	CRect r;
	
	GetRect(&r);
	DrawMenuBar(&r,item,100);
	
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="mb_";
item[i++]= "File";
item[i++]= "Edit";
item[i++]= "Help";

]]>
</default>
</MenuBar>

<MenuWindow isnode="true" icon="32" include="/WorkShop/UserLibs">
<code>
<![CDATA[
#include "gui.h"

char *var;
char *ivar[100];
char *item[100];
int i;

void init()
{
	int j;
	
	for(j = 0; j < 100; j++)
	{
		item[j] = NULL;
		ivar[j] = NULL;
	}
	
	i = 0;
	_init_attrib();
}
void code_0()
{
}
void code_1()
{
}
void code_2()
{
	LOG("CMenuWnd *%s;\n",var);
	
	for(int j = 0; j < 100; j++)
	{
		if(ivar[j] && ivar[j][0] != '-')
		{
			LOG("CMenuItem *%s;\n",ivar[j]);
		}
	}
}
void code_3()
{
	CRect rc;
	
	GetRect(&rc);
	rc.Normalize();
	
	LOG("\nthis->%s = CMenuWnd::CreateMenuWnd(this->id);\n",var);
	
	for(int j = 0; j < 100; j++)
	{
		if(ivar[j])
		{
			LOG("\nNEW(this->%s,CMenuItem);\n",ivar[j]);
			LOG("this->%s->Init();\n",ivar[j]);
			LOG("this->%s->SetName(\"%s\");\n",ivar[j],item[j]);
		}
	}
}
void code_4()
{
	for(int j = 0; j < 100; j++)
	{
		if(item[j])
		{
			if(item[j][0] != '-')
			{
				LOG("this->%s->AddMenuItem(%s);\n",var,ivar[j]);
			}
			else
			{
				LOG("this->%s->AddSeparator();\n",var);
			}
		}
	}
}
int code(int code_num)
{
	
	init();
	switch(code_num)
	{
		case 0: code_0();break;
		case 1: code_1();break;
		case 2: code_2();break;
		case 3: code_3();break;
		case 4: code_4();break;
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	init();
	CRect r;
	
	GetRect(&r);
	DrawMenuWnd(&r,item,100);
	
	return OK;
}
]]>
</code>
<default>
<![CDATA[
var="mwnd_";

ivar[i] = "mi_copy";
item[i++]= "Copy";

ivar[i] = "mi_cut";
item[i++]= "Cut";

ivar[i] = "mi_paste";
item[i++]= "Paste";

item[i++]= "---";

ivar[i] = "mi_selall";
item[i++]= "Select All";

]]>
</default>
</MenuWindow>
</moonGUI>
< isnode="true" icon="32">
< isnode="true"  include="/WorkShop/PCB">
<code>
<![CDATA[
#include "pcb.h"

int dot_width = 5;
int width;
int height;

int code(int code_num)
{
  return OK;
}
int before_draw()
{
	CRect r;
	GetRect(&r);
	
	align_rect(&r,1);
	fix_rect_pos(&r,0,0);
	fix_rect(&r,50,50);
	
	SetRect(&r);
	
	return OK;
}
int draw()
{	
	int i,j,offx,offy;
	CRect r;
	
	GetRect(&r);
	r.Normalize();
	
	SetPen(PS_SOLID,0,RGB(0,0,0));
	DrawRect(&r);
	
	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(0,0,0));
	SetStockFont(DEFAULT_GUI_FONT);
	DrawText("",&r,DT_CENTER|DT_VCENTER|DT_SINGLELINE);
	
	offx = 5 * HOLE_WIDTH;
	offy = 5 * HOLE_WIDTH;
	
	for(j = 0; j < height; j++)
	{
		for(i = 0; i < width; i++)
		{
			r.left = offx + i * HOLE_WIDTH - dot_width;
			r.top = offy - dot_width + j * HOLE_WIDTH;
			r.right = r.left + 2*dot_width -1;
			r.bottom = r.top +  2*dot_width -1;
			
			SetPen(PS_SOLID,1,RGB(245,239,116));
			Arc(r.left,r.top,r.right,r.bottom,r.left,r.top,r.left,r.top);		
		}
	}
	
	char buf[100];	
	for(i = 0 ;i < width; i++)
	{
		sprintf(buf,"%d",i+1);

		r.left = offx + i * HOLE_WIDTH - dot_width;
		r.top = offy- HOLE_WIDTH - 5;
		r.right = r.left + 100;
		r.bottom = r.top + 100;

		DrawText(buf,&r,DT_LEFT);
	}
	
	for(i = 0; i < height; i++)
	{
		r.left = offx - HOLE_WIDTH - 5;
		r.top = offy - dot_width + i * HOLE_WIDTH;
		r.right = r.left + 100;
		r.bottom = r.top + 100;
				
		if(i < 26)	sprintf(buf,"%c",'A'+i);
		else sprintf(buf,"%c",'a'+i-26);
		
		DrawText(buf,&r,DT_LEFT);
	}
	return OK;
}

]]>
</code>
<default>
<![CDATA[

width = 30;
height = 20;

]]>
</default>

</>

< isnode="true">
<code>
<![CDATA[

COLORREF text_color;
char *text;

int code(int code_num)
{
  return OK;
}

int before_draw()
{
	return OK;
}

int draw()
{
	CRect r;

	GetRect(&r);
	r.Normalize();
	
	SetBkMode(TRANSPARENT);
	SetTextColor(text_color);
	SetStockFont(DEFAULT_GUI_FONT);
			
	DrawText(text,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);
	
	return OK;
}
]]>
</code>
<default>
<![CDATA[

text = "";
text_color = RGB(0,0,0);

]]>
</default>
</>

< isnode="true"  include="/WorkShop/PCB">
<code>
<![CDATA[
#include "pcb.h"

COLORREF color;

int code(int code_num)
{
  return OK;
}
int before_draw()
{
	CRect r;
	GetRect(&r);
	
	align_rect(&r,1);
	r.bottom = r.top + 6;
	
	SetRect(&r);
	
	return OK;
}
int draw()
{	
	int i,j;
	CRect r;
	
	GetRect(&r);
	r.Normalize();
	
	SetPen(PS_SOLID,2,color);
	DrawLine(r.left,r.top,r.right,r.top);
	draw_connect_dot(r.left,r.top);
	draw_connect_dot(r.right,r.top);
	return OK;
}

]]>
</code>
<default>
<![CDATA[

color = RGB(0,0,0);

]]>
</default>

</>
< isnode="true"  include="/WorkShop/PCB">
<code>
<![CDATA[
#include "pcb.h"

COLORREF color;

int code(int code_num)
{
  return OK;
}
int before_draw()
{
	CRect r;
	GetRect(&r);
	
	align_rect(&r,1);
	r.right = r.left + 6;
	
	SetRect(&r);
	
	return OK;
}
int draw()
{	
	int i,j;
	CRect r;
	
	GetRect(&r);
	r.Normalize();
	
	SetPen(PS_SOLID,2,color);
	DrawLine(r.left,r.top,r.left,r.bottom);
	draw_connect_dot(r.left,r.top);
	draw_connect_dot(r.left,r.bottom);
	
	return OK;
}

]]>
</code>
<default>
<![CDATA[

color = RGB(0,0,0);

]]>
</default>

</>
< isnode="true"  include="/WorkShop/PCB">
<code>
<![CDATA[
#include "pcb.h"

COLORREF color;

int code(int code_num)
{
  return OK;
}
int before_draw()
{
	CRect r;
	GetRect(&r);
	align_rect(&r,0);
	SetRect(&r);
	
	return OK;
}
int draw()
{	
	int i,j;
	CRect r;	
	GetRect(&r);
		
	SetPen(PS_SOLID,2,color);
	
	DrawLine(r.left,r.top,r.right,r.bottom);
	draw_connect_dot(r.left,r.top);
	draw_connect_dot(r.right,r.bottom);
	return OK;
}

]]>
</code>
<default>
<![CDATA[

color=RGB(0,0,0);

]]>
</default>
</>
< isnode="true"  include="/WorkShop/PCB">
<code>
<![CDATA[
#include "pcb.h"
char *name;

int code(int code_num)
{
  return OK;
}
int before_draw()
{
	return OK;
}
int draw_1()
{
	CRect r,rt,rc;
	GetRect(&r);
	r.Normalize();
	
	int cx = r.left+ r.GetWidth() / 2;
	int cy = r.top + r.GetHeight() / 2;

	int x1,y1,x2,y2; //
	
	x1 = r.left;y1 = cy;
	align(&x1);align(&y1);
	
	x2 = r.right; y2 = cy;
	align(&x2);align(&y2);
	
	int crw = 32,crh = 12; //
	
	if(x2 - x1 > crw)
	{
		rc.left = x1 + (x2-x1) / 2 - crw / 2;
		rc.top =  y2 - crh / 2;
		rc.right = rc.left + crw;
		rc.bottom = rc.top + crh;
		
		SetPen(PS_SOLID,2,RGB(0,0,0));
		DrawLine(x1,y2,rc.left,y2);
		DrawLine(x2,y2,rc.right,y2);		
	}
	else
	{
		if(x2 - x1 < HOLE_WIDTH)
			x2 = x1 + HOLE_WIDTH;
			
		rc.left = x1;
		rc.top =  y2 - crh / 2;
		rc.right = x2;
		rc.bottom = rc.top + crh;
		//SetRect(&rc);
	}

	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(255,0,0));
	SetStockFont(DEFAULT_GUI_FONT);		
	DrawText(name,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);

	SetPen(PS_SOLID,2,RGB(0,0,255));
	DrawRect_2(&rc);
	
	draw_connect_dot(x1,y1);
	draw_connect_dot(x2,y2);
	
	return OK;
}
int draw_2()
{
	CRect r,rt,rc;
	GetRect(&r);
	r.Normalize();
	
	int cx = r.left+ r.GetWidth() / 2;
	int cy = r.top + r.GetHeight() / 2;

	int x1,y1,x2,y2; //
	
	x1 = cx;y1 = r.top;
	align(&x1);align(&y1);
	
	x2 = cx; y2 = r.bottom;
	align(&x2);align(&y2);
	
	int crh = 32,crw = 12; //
	
	if(y2 - y1 > crh)
	{
		rc.left = x1 - crw / 2;
		rc.top =  y1 - crh / 2 + (y2-y1)/2;
		rc.right = rc.left + crw;
		rc.bottom = rc.top + crh;
		
		SetPen(PS_SOLID,2,RGB(0,0,0));
		DrawLine(x1,y1,x1,rc.top);
		DrawLine(x2,y2,x2,rc.bottom);
	}
	else
	{
		if(y2 - y1 < HOLE_WIDTH)
			y2 = y1 + HOLE_WIDTH;			
		rc.left = x1 - crw / 2;
		rc.top =  y1;
		rc.right = rc.left + crw;
		rc.bottom = y2;
		//SetRect(&rc);
	}

	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(255,0,0));
	SetStockFont(DEFAULT_GUI_FONT);		
	DrawText(name,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);

	SetPen(PS_SOLID,2,RGB(0,0,255));
	DrawRect_2(&rc);
	
	draw_connect_dot(x1,y1);
	draw_connect_dot(x2,y2);
	
	return OK;
}
int draw()
{	
	CRect r;
	GetRect(&r);
	r.Normalize();
	
	if(r.GetWidth() >= r.GetHeight())
		draw_1();
	else
		draw_2();
	
	return OK;
}

]]>
</code>
<default>
<![CDATA[
name = "R1"; //
]]>
</default>

</>


< isnode="true"  include="/WorkShop/PCB">
<code>
<![CDATA[
#include "pcb.h"
char *name;

int code(int code_num)
{
  return OK;
}
int before_draw()
{
	return OK;
}
int draw_1()
{
	CRect r,rt,rc;
	GetRect(&r);
	r.Normalize();
	
	int cx = r.left+ r.GetWidth() / 2;
	int cy = r.top + r.GetHeight() / 2;

	int x1,y1,x2,y2; //
	
	x1 = r.left;y1 = cy;
	align(&x1);align(&y1);
	
	x2 = r.right; y2 = cy;
	align(&x2);align(&y2);
	
	int crw = 32,crh = 12; //
	
	if(x2 - x1 > crw)
	{
	
		rc.left = x1 + (x2-x1) / 2 - crw / 2;
		rc.top =  y2 - crh / 2;
		rc.right = rc.left + crw;
		rc.bottom = rc.top + crh;	
	}
	else
	{
		if(x2 - x1 < HOLE_WIDTH)
			x2 = x1 + HOLE_WIDTH;			
		rc.left = x1;
		rc.top =  y2 - crh / 2;
		rc.right = x2;
		rc.bottom = rc.top + crh;
		//SetRect(&rc);
	}
	
	cx = rc.left+ rc.GetWidth() / 2;
	cy = rc.top + rc.GetHeight() / 2;

	rt.Copy(&rc);
	rt.left = cx - 3;
	rt.right = cx + 3;
	
	SetPen(PS_SOLID,2,RGB(0,0,0));
	DrawLine(x1,y2,rt.left,y2);
	DrawLine(x2,y2,rt.right,y2);	

	SetPen(PS_SOLID,2,RGB(0,0,255));		
	DrawLine(rt.left,rt.top,rt.left,rt.bottom);
	DrawLine(rt.right,rt.top,rt.right,rt.bottom);
	
	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(255,0,0));
	SetStockFont(DEFAULT_GUI_FONT);		
	DrawText(name,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);
	
	draw_connect_dot(x1,y1);
	draw_connect_dot(x2,y2);
	
	return OK;
}
int draw_2()
{
	CRect r,rt,rc;
	GetRect(&r);
	r.Normalize();
	
	int cx = r.left+ r.GetWidth() / 2;
	int cy = r.top + r.GetHeight() / 2;

	int x1,y1,x2,y2; //
	
	x1 = cx;y1 = r.top;
	align(&x1);align(&y1);
	
	x2 = cx; y2 = r.bottom;
	align(&x2);align(&y2);
	
	int crh = 32,crw = 12; //
	
	if(y2 - y1 > crh)
	{
		rc.left = x1 - crw / 2;
		rc.top =  y1 - crh / 2 + (y2-y1)/2;
		rc.right = rc.left + crw;
		rc.bottom = rc.top + crh;		
	}
	else
	{
		if(y2 - y1 < HOLE_WIDTH)
			y2 = y1 + HOLE_WIDTH;			
		rc.left = x1 - crw / 2;
		rc.top =  y1;
		rc.right = rc.left + crw;
		rc.bottom = y2;
		//SetRect(&rc);
	}

	cx = rc.left+ rc.GetWidth() / 2;
	cy = rc.top + rc.GetHeight() / 2;

	rt.Copy(&rc);
	rt.top = cy - 3;
	rt.bottom = cy + 3;
	
	SetPen(PS_SOLID,2,RGB(0,0,0));
	DrawLine(x1,y1,x1,rt.top);
	DrawLine(x2,y2,x2,rt.bottom);

	SetPen(PS_SOLID,0,RGB(0,0,255));
	DrawLine(rt.left,rt.top,rt.right,rt.top);
	DrawLine(rt.left,rt.top-1,rt.right,rt.top-1);
	DrawLine(rt.left,rt.bottom,rt.right,rt.bottom);
	DrawLine(rt.left,rt.bottom+1,rt.right,rt.bottom+1);
	
	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(255,0,0));
	SetStockFont(DEFAULT_GUI_FONT);		
	DrawText(name,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);
	
	draw_connect_dot(x1,y1);
	draw_connect_dot(x2,y2);
	
	return OK;
}
int draw()
{	
	CRect r;
	GetRect(&r);
	r.Normalize();
	
	if(r.GetWidth() >= r.GetHeight())
		draw_1();
	else
		draw_2();
	
	return OK;
}

]]>
</code>
<default>
<![CDATA[
name = "C1"; //
]]>
</default>
</>

< isnode="true"  include="/WorkShop/PCB">
<code>
<![CDATA[
#include "pcb.h"
char *name;

int code(int code_num)
{
  return OK;
}
int before_draw()
{
	return OK;
}
int draw_1()
{
	CRect r,rt,rc;
	GetRect(&r);	
	int mode = (r.GetWidth()>0)?1:2;
	r.Normalize();
		
	int cx = r.left+ r.GetWidth() / 2;
	int cy = r.top + r.GetHeight() / 2;

	int x1,y1,x2,y2; //
	
	x1 = r.left;y1 = cy;
	align(&x1);align(&y1);
	
	x2 = r.right; y2 = cy;
	align(&x2);align(&y2);
	
	int crw = 32,crh = 12; //
	
	if(x2 - x1 > crw)
	{
		rc.left = x1 + (x2-x1) / 2 - crw / 2;
		rc.right = rc.left + crw;
		rc.top =  y2 - crh / 2;		
		rc.bottom = rc.top + crh;	
	}
	else
	{
		if(x2 - x1 < HOLE_WIDTH)
			x2 = x1 + HOLE_WIDTH;			
		if(mode == 1)	
		{rc.left = x1;rc.right = x2;}
		else
		{rc.left = x2;rc.right = x1;}
		rc.top =  y2 - crh / 2;		
		rc.bottom = rc.top + crh;
		//SetRect(&rc);
	}
	
	cx = rc.left+ rc.GetWidth() / 2;
	cy = rc.top + rc.GetHeight() / 2;

	rt.Copy(&rc);
	rt.left = cx - 4;
	rt.right = cx + 3;
		
	CRect rx;
	rx.Copy(&rt);
	if(mode == 1)
		rx.left = rx.right - 3;
	else
		rx.right = rx.left + 3;
	
	SetPen(PS_SOLID,2,RGB(0,0,0));			
	DrawLine(x1,y2,rt.left,y2);
	DrawLine(x2,y2,rt.right,y2);	

	SetPen(PS_SOLID,2,RGB(0,0,255));		
	DrawRect_2(&rx);
	DrawLine(rt.left,rt.top,rt.left,rt.bottom);
	DrawLine(rt.right,rt.top,rt.right,rt.bottom);
	
	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(255,0,0));
	SetStockFont(DEFAULT_GUI_FONT);		
	DrawText(name,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);
	
	draw_connect_dot(x1,y1);
	draw_connect_dot(x2,y2);
	
	return OK;
}
int draw_2()
{
	CRect r,rt,rc;
	GetRect(&r);
	int mode = (r.GetHeight()>0)?1:2;	
	r.Normalize();
	
	int cx = r.left+ r.GetWidth() / 2;
	int cy = r.top + r.GetHeight() / 2;

	int x1,y1,x2,y2; //
	
	x1 = cx;y1 = r.top;
	align(&x1);align(&y1);
	
	x2 = cx; y2 = r.bottom;
	align(&x2);align(&y2);
	
	int crh = 32,crw = 12; //
	
	if(y2 - y1 > crh)
	{
		rc.left = x1 - crw / 2;
		rc.top =  y1 - crh / 2 + (y2-y1)/2;
		rc.right = rc.left + crw;
		rc.bottom = rc.top + crh;		
	}
	else
	{
		if(y2 - y1 < HOLE_WIDTH)
			y2 = y1 + HOLE_WIDTH;			
		rc.left = x1 - crw / 2;		
		rc.right = rc.left + crw;
		if(mode == 1)
		{rc.top =  y1;	rc.bottom = y2;}
		else
		{rc.top =  y2;	rc.bottom = y1;}
		//SetRect(&rc);
	}

	cx = rc.left+ rc.GetWidth() / 2;
	cy = rc.top + rc.GetHeight() / 2;

	rt.Copy(&rc);
	rt.top = cy - 3;
	rt.bottom = cy + 3;
	
	CRect rx;
	rx.Copy(&rt);
	if(mode == 1)
	{
		rx.top = rx.bottom - 4;
	}
	else
	{
		rx.top -- ;
		rx.bottom = rx.top + 4;
	}
		
	SetPen(PS_SOLID,2,RGB(0,0,0));		
	DrawLine(x1,y1,x1,rt.top);
	DrawLine(x2,y2,x2,rt.bottom);

	SetPen(PS_SOLID,2,RGB(0,0,255));
	DrawRect_2(&rx);
	SetPen(PS_SOLID,0,RGB(0,0,255));
	
	DrawLine(rt.left-1,rt.top,rt.right+1,rt.top);
	DrawLine(rt.left-1,rt.top-1,rt.right+1,rt.top-1);
	DrawLine(rt.left-1,rt.bottom,rt.right+1,rt.bottom);
	DrawLine(rt.left-1,rt.bottom-1,rt.right+1,rt.bottom-1);
	
	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(255,0,0));
	SetStockFont(DEFAULT_GUI_FONT);		
	DrawText(name,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);
	
	draw_connect_dot(x1,y1);
	draw_connect_dot(x2,y2);
	
	return OK;
}
int draw()
{	
	CRect r;
	GetRect(&r);
	r.Normalize();
	
	if(r.GetWidth() >= r.GetHeight())
		draw_1();
	else
		draw_2();
	
	return OK;
}

]]>
</code>
<default>
<![CDATA[
name = "C1"; //
]]>
</default>

</>

< isnode="true"  include="/WorkShop/PCB">
<code>
<![CDATA[
#include "pcb.h"
char *name;

int code(int code_num)
{
  return OK;
}
int before_draw()
{
	return OK;
}
int draw_1()
{
	CRect r,rt,rc;
	GetRect(&r);	
	int mode = (r.GetWidth()>0)?1:2;
	r.Normalize();
		
	int cx = r.left+ r.GetWidth() / 2;
	int cy = r.top + r.GetHeight() / 2;

	int x1,y1,x2,y2; //
	
	x1 = r.left;y1 = cy;
	align(&x1);align(&y1);
	
	x2 = r.right; y2 = cy;
	align(&x2);align(&y2);
	
	int crw = 32,crh = 12; //
	
	if(x2 - x1 > crw)
	{
		rc.left = x1 + (x2-x1) / 2 - crw / 2;
		rc.right = rc.left + crw;
		rc.top =  y2 - crh / 2;		
		rc.bottom = rc.top + crh;	
	}
	else
	{
		if(x2 - x1 < HOLE_WIDTH)
			x2 = x1 + HOLE_WIDTH;			
		if(mode == 1)	
		{rc.left = x1;rc.right = x2;}
		else
		{rc.left = x2;rc.right = x1;}
		rc.top =  y2 - crh / 2;		
		rc.bottom = rc.top + crh;
		//SetRect(&rc);
	}
	
	cx = rc.left+ rc.GetWidth() / 2;
	cy = rc.top + rc.GetHeight() / 2;

	rt.Copy(&rc);
	rt.left = cx - 5;
	rt.right = cx + 5;
	
	SetPen(PS_SOLID,2,RGB(0,0,0));			
	DrawLine(x1,y2,rt.left,y2);
	DrawLine(x2,y2,rt.right,y2);	

	SetPen(PS_SOLID,2,RGB(0,0,255));		
	DrawLine(rt.left,rt.top,rt.left,rt.bottom);
	DrawLine(rt.right,rt.top,rt.right,rt.bottom);
	
	if(mode == 1)
	{
		DrawLine(rt.left,rt.top,rt.right,cy);
		DrawLine(rt.left,rt.bottom,rt.right,cy);
	}
	else
	{
		DrawLine(rt.left,cy,rt.right,rt.top);
		DrawLine(rt.left,cy,rt.right,rt.bottom);
	}
			
	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(255,0,0));
	SetStockFont(DEFAULT_GUI_FONT);		
	DrawText(name,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);
	
	draw_connect_dot(x1,y1);
	draw_connect_dot(x2,y2);
	
	return OK;
}
int draw_2()
{
	CRect r,rt,rc;
	GetRect(&r);
	int mode = (r.GetHeight()>0)?1:2;	
	r.Normalize();
	
	int cx = r.left+ r.GetWidth() / 2;
	int cy = r.top + r.GetHeight() / 2;

	int x1,y1,x2,y2; //
	
	x1 = cx;y1 = r.top;
	align(&x1);align(&y1);
	
	x2 = cx; y2 = r.bottom;
	align(&x2);align(&y2);
	
	int crh = 32,crw = 12; //
	
	if(y2 - y1 > crh)
	{
		rc.left = x1 - crw / 2;
		rc.top =  y1 - crh / 2 + (y2-y1)/2;
		rc.right = rc.left + crw;
		rc.bottom = rc.top + crh;		
	}
	else
	{
		if(y2 - y1 < HOLE_WIDTH)
			y2 = y1 + HOLE_WIDTH;			
		rc.left = x1 - crw / 2;		
		rc.right = rc.left + crw;
		if(mode == 1)
		{rc.top =  y1;	rc.bottom = y2;}
		else
		{rc.top =  y2;	rc.bottom = y1;}
		//SetRect(&rc);
	}

	cx = rc.left+ rc.GetWidth() / 2;
	cy = rc.top + rc.GetHeight() / 2;

	rt.Copy(&rc);
	rt.top = cy - 5;
	rt.bottom = cy + 5;
	
	SetPen(PS_SOLID,2,RGB(0,0,0));		
	DrawLine(x1,y1,x1,rt.top);
	DrawLine(x2,y2,x2,rt.bottom);

	SetPen(PS_SOLID,2,RGB(0,0,255));
	DrawLine(rt.left,rt.top,rt.right,rt.top);
	DrawLine(rt.left,rt.bottom,rt.right,rt.bottom);

	if(mode == 1)
	{
		DrawLine(rt.left,rt.top,cx,rt.bottom);
		DrawLine(rt.right,rt.top,cx,rt.bottom);
	}
	else
	{
		DrawLine(rt.left,rt.bottom,cx,rt.top);
		DrawLine(rt.right,rt.bottom,cx,rt.top);
	}
		
	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(255,0,0));
	SetStockFont(DEFAULT_GUI_FONT);		
	DrawText(name,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);
	
	draw_connect_dot(x1,y1);
	draw_connect_dot(x2,y2);
	
	return OK;
}
int draw()
{	
	CRect r;
	GetRect(&r);
	r.Normalize();
	
	if(r.GetWidth() >= r.GetHeight())
		draw_1();
	else
		draw_2();
	
	return OK;
}

]]>
</code>
<default>
<![CDATA[
name = "D1"; //
]]>
</default>

</>
< isnode="true"  include="/WorkShop/PCB">
<code>
<![CDATA[
#include "pcb.h"
char *name;

int code(int code_num)
{
  return OK;
}
int before_draw()
{
	return OK;
}
int draw_1()
{
	CRect r,rt,rc;
	GetRect(&r);	
	int mode = (r.GetWidth()>0)?1:2;
	r.Normalize();
		
	int cx = r.left+ r.GetWidth() / 2;
	int cy = r.top + r.GetHeight() / 2;

	int x1,y1,x2,y2; //
	
	x1 = r.left;y1 = cy;
	align(&x1);align(&y1);
	
	x2 = r.right; y2 = cy;
	align(&x2);align(&y2);
	
	int crw = 32,crh = 12; //
	
	if(x2 - x1 > crw)
	{
		rc.left = x1 + (x2-x1) / 2 - crw / 2;
		rc.right = rc.left + crw;
		rc.top =  y2 - crh / 2;		
		rc.bottom = rc.top + crh;	
	}
	else
	{
		if(x2 - x1 < HOLE_WIDTH)
			x2 = x1 + HOLE_WIDTH;			
		if(mode == 1)	
		{rc.left = x1;rc.right = x2;}
		else
		{rc.left = x2;rc.right = x1;}
		rc.top =  y2 - crh / 2;		
		rc.bottom = rc.top + crh;
		//SetRect(&rc);
	}
	
	cx = rc.left+ rc.GetWidth() / 2;
	cy = rc.top + rc.GetHeight() / 2;

	rt.Copy(&rc);
	rt.left = cx - 5;
	rt.right = cx + 5;
	
	SetPen(PS_SOLID,2,RGB(0,0,0));			
	DrawLine(x1,y2,rt.left,y2);
	DrawLine(x2,y2,rt.right,y2);	

	SetPen(PS_SOLID,2,RGB(0,0,255));		
	DrawLine(rt.left,rt.top,rt.left,rt.bottom);
	DrawLine(rt.right,rt.top,rt.right,rt.bottom);
	
	if(mode == 1)
	{
		DrawLine(rt.left,rt.top,rt.right,cy);
		DrawLine(rt.left,rt.bottom,rt.right,cy);
		DrawLine(rt.right,rt.top,rt.right + 4,rt.top-3);
		DrawLine(rt.right,rt.bottom,rt.right - 4,rt.bottom+3);
	}
	else
	{
		DrawLine(rt.left,cy,rt.right,rt.top);
		DrawLine(rt.left,cy,rt.right,rt.bottom);
		DrawLine(rt.left,rt.top,rt.left - 4,rt.top-3);
		DrawLine(rt.left,rt.bottom,rt.left + 4,rt.bottom+3);
	}
			
	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(255,0,0));
	SetStockFont(DEFAULT_GUI_FONT);		
	DrawText(name,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);
	
	draw_connect_dot(x1,y1);
	draw_connect_dot(x2,y2);
	
	return OK;
}
int draw_2()
{
	CRect r,rt,rc;
	GetRect(&r);
	int mode = (r.GetHeight()>0)?1:2;	
	r.Normalize();
	
	int cx = r.left+ r.GetWidth() / 2;
	int cy = r.top + r.GetHeight() / 2;

	int x1,y1,x2,y2; //
	
	x1 = cx;y1 = r.top;
	align(&x1);align(&y1);
	
	x2 = cx; y2 = r.bottom;
	align(&x2);align(&y2);
	
	int crh = 32,crw = 12; //
	
	if(y2 - y1 > crh)
	{
		rc.left = x1 - crw / 2;
		rc.top =  y1 - crh / 2 + (y2-y1)/2;
		rc.right = rc.left + crw;
		rc.bottom = rc.top + crh;		
	}
	else
	{
		if(y2 - y1 < HOLE_WIDTH)
			y2 = y1 + HOLE_WIDTH;			
		rc.left = x1 - crw / 2;		
		rc.right = rc.left + crw;
		if(mode == 1)
		{rc.top =  y1;	rc.bottom = y2;}
		else
		{rc.top =  y2;	rc.bottom = y1;}
		//SetRect(&rc);
	}

	cx = rc.left+ rc.GetWidth() / 2;
	cy = rc.top + rc.GetHeight() / 2;

	rt.Copy(&rc);
	rt.top = cy - 5;
	rt.bottom = cy + 5;
	
	SetPen(PS_SOLID,2,RGB(0,0,0));		
	DrawLine(x1,y1,x1,rt.top);
	DrawLine(x2,y2,x2,rt.bottom);

	SetPen(PS_SOLID,2,RGB(0,0,255));
	DrawLine(rt.left,rt.top,rt.right,rt.top);
	DrawLine(rt.left,rt.bottom,rt.right,rt.bottom);
	
	if(mode == 1)
	{
		DrawLine(rt.left,rt.top,cx,rt.bottom);
		DrawLine(rt.right,rt.top,cx,rt.bottom);
		DrawLine(rt.left,rt.bottom,rt.left-4,rt.bottom-3);
		DrawLine(rt.right,rt.bottom,rt.right+4,rt.bottom+3);
	}
	else
	{
		DrawLine(rt.left,rt.bottom,cx,rt.top);
		DrawLine(rt.right,rt.bottom,cx,rt.top);
		DrawLine(rt.left,rt.top,rt.left-4,rt.top-3);
		DrawLine(rt.right,rt.top,rt.right+4,rt.top+3);
	
	}
		
	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(255,0,0));
	SetStockFont(DEFAULT_GUI_FONT);		
	DrawText(name,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);
	
	draw_connect_dot(x1,y1);
	draw_connect_dot(x2,y2);
	
	return OK;
}
int draw()
{	
	CRect r;
	GetRect(&r);
	r.Normalize();
	
	if(r.GetWidth() >= r.GetHeight())
		draw_1();
	else
		draw_2();
	
	return OK;
}

]]>
</code>
<default>
<![CDATA[
name = "D1"; //
]]>
</default>

</>
< isnode="true"  include="/WorkShop/PCB">
<code>
<![CDATA[
#include "pcb.h"
char *name;

int code(int code_num)
{
  return OK;
}
int before_draw()
{
	return OK;
}
int draw_1()
{
	CRect r,rt,rc;
	GetRect(&r);	
	int mode = (r.GetWidth()>0)?1:2;
	r.Normalize();
		
	int cx = r.left+ r.GetWidth() / 2;
	int cy = r.top + r.GetHeight() / 2;

	int x1,y1,x2,y2; //
	
	x1 = r.left;y1 = cy;
	align(&x1);align(&y1);
	
	x2 = r.right; y2 = cy;
	align(&x2);align(&y2);
	
	int crw = 32,crh = 12; //
	
	if(x2 - x1 > crw)
	{
		rc.left = x1 + (x2-x1) / 2 - crw / 2;
		rc.right = rc.left + crw;
		rc.top =  y2 - crh / 2;		
		rc.bottom = rc.top + crh;	
	}
	else
	{
		if(x2 - x1 < HOLE_WIDTH)
			x2 = x1 + HOLE_WIDTH;			
		if(mode == 1)	
		{rc.left = x1;rc.right = x2;}
		else
		{rc.left = x2;rc.right = x1;}
		rc.top =  y2 - crh / 2;		
		rc.bottom = rc.top + crh;
		//SetRect(&rc);
	}
	
	cx = rc.left+ rc.GetWidth() / 2;
	cy = rc.top + rc.GetHeight() / 2;

	rt.Copy(&rc);
	rt.left = cx - 5;
	rt.right = cx + 5;
	
	SetPen(PS_SOLID,2,RGB(0,0,0));			
	DrawLine(x1,y2,rt.left,y2);
	DrawLine(x2,y2,rt.right,y2);	

	SetPen(PS_SOLID,2,RGB(255,0,0));		
	DrawLine(rt.left,rt.top,rt.left,rt.bottom);
	DrawLine(rt.right,rt.top,rt.right,rt.bottom);
	
	if(mode == 1)
	{
		DrawLine(rt.left,rt.top,rt.right,cy);
		DrawLine(rt.left,rt.bottom,rt.right,cy);
	}
	else
	{
		DrawLine(rt.left,cy,rt.right,rt.top);
		DrawLine(rt.left,cy,rt.right,rt.bottom);
	}
	
	int ridus = 10;
	rt.left = cx - ridus;
	rt.right = cx + ridus;
	rt.top = cy - ridus;
	rt.bottom = cy + ridus;
	
	DrawCircle(&rt);
			
	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(0,0,255));
	SetStockFont(DEFAULT_GUI_FONT);		
	DrawText(name,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);
	
	draw_connect_dot(x1,y1);
	draw_connect_dot(x2,y2);
	
	return OK;
}
int draw_2()
{
	CRect r,rt,rc;
	GetRect(&r);
	int mode = (r.GetHeight()>0)?1:2;	
	r.Normalize();
	
	int cx = r.left+ r.GetWidth() / 2;
	int cy = r.top + r.GetHeight() / 2;

	int x1,y1,x2,y2; //
	
	x1 = cx;y1 = r.top;
	align(&x1);align(&y1);
	
	x2 = cx; y2 = r.bottom;
	align(&x2);align(&y2);
	
	int crh = 32,crw = 12; //
	
	if(y2 - y1 > crh)
	{
		rc.left = x1 - crw / 2;
		rc.top =  y1 - crh / 2 + (y2-y1)/2;
		rc.right = rc.left + crw;
		rc.bottom = rc.top + crh;		
	}
	else
	{
		if(y2 - y1 < HOLE_WIDTH)
			y2 = y1 + HOLE_WIDTH;			
		rc.left = x1 - crw / 2;		
		rc.right = rc.left + crw;
		if(mode == 1)
		{rc.top =  y1;	rc.bottom = y2;}
		else
		{rc.top =  y2;	rc.bottom = y1;}
		//SetRect(&rc);
	}

	cx = rc.left+ rc.GetWidth() / 2;
	cy = rc.top + rc.GetHeight() / 2;

	rt.Copy(&rc);
	rt.top = cy - 5;
	rt.bottom = cy + 5;
	
	SetPen(PS_SOLID,2,RGB(0,0,0));		
	DrawLine(x1,y1,x1,rt.top);
	DrawLine(x2,y2,x2,rt.bottom);

	SetPen(PS_SOLID,2,RGB(255,0,0));
	DrawLine(rt.left,rt.top,rt.right,rt.top);
	DrawLine(rt.left,rt.bottom,rt.right,rt.bottom);

	if(mode == 1)
	{
		DrawLine(rt.left,rt.top,cx,rt.bottom);
		DrawLine(rt.right,rt.top,cx,rt.bottom);
	}
	else
	{
		DrawLine(rt.left,rt.bottom,cx,rt.top);
		DrawLine(rt.right,rt.bottom,cx,rt.top);
	}
	
	int ridus = 10;
	rt.left = cx - ridus;
	rt.right = cx + ridus;
	rt.top = cy - ridus;
	rt.bottom = cy + ridus;
	
	DrawCircle(&rt);
					
	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(0,0,255));
	SetStockFont(DEFAULT_GUI_FONT);		
	DrawText(name,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);
	
	draw_connect_dot(x1,y1);
	draw_connect_dot(x2,y2);
	
	return OK;
}
int draw()
{	
	CRect r;
	GetRect(&r);
	r.Normalize();
	
	if(r.GetWidth() >= r.GetHeight())
		draw_1();
	else
		draw_2();
	
	return OK;
}

]]>
</code>
<default>
<![CDATA[
name = "D1"; //
]]>
</default>

</>
<IC isnode="true"  include="/WorkShop/PCB">
<code>
<![CDATA[
#include "pcb.h"
char *name;

int code(int code_num)
{
  return OK;
}
int before_draw()
{
	CRect r;
	
	GetRect(&r);
	//align_rect(&r,0);
	SetRect(&r);
	
	return OK;
}
int draw_1()
{
	CRect r,rt,rc;
	GetRect(&r);	
	int mode = (r.GetWidth()>0)?1:2;
	r.Normalize();
		
	rc.Copy(&r);
	align_rect(&rc,1);

	int border = 8;	
	rt.Copy(&rc);
	rt.left -= border;
	rt.right += border;
	rt.top -= border;
	rt.bottom += border;
	
	SetPen(PS_SOLID,2,RGB(0,0,0));
	DrawRect_2(&rt);
	
	int i,k=0,max;
	char buf[100];
	
	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(0,255,0));
	SetStockFont(DEFAULT_GUI_FONT);		

	int width_mode = 0;
	if(rc.bottom - rc.top >= 2*HOLE_WIDTH)
		width_mode = 1;
	
	int two_line = rc.bottom - rc.top >= HOLE_WIDTH;
	
	max = rc.GetWidth() / HOLE_WIDTH + 1;		
	for(i = rc.left; i <= rc.right; i+= HOLE_WIDTH)
	{
		draw_connect_dot(i,rc.top);
		if(mode == 1)
		{
			if(two_line)
				sprintf(buf,"%d",2*max-k);
			else
				sprintf(buf,"%d",k+1);
		}
		else
			sprintf(buf,"%d", max-k);
		k++;
			
		if(width_mode)
			TextOut(i-4,rc.top+3,buf);
		else
			TextOut(i-4,rc.top-15,buf);
	}
	
	k = 0;
	if(two_line)
	{
		for(i = rc.left; i <= rc.right; i+= HOLE_WIDTH)
		{
			draw_connect_dot(i,rc.bottom);
			if(mode == 1)
				sprintf(buf,"%d",k+1);
			else
				sprintf(buf,"%d",max+k+1);
			k++;
	
			if(width_mode)
				TextOut(i-4,rc.bottom-15,buf);
			else
				TextOut(i-4,rc.bottom+3,buf);
		}
		
		SetPen(PS_SOLID,2,RGB(0,0,0));
		
		int ridus = 6;
		if(mode == 1)
		{
			rc.left = rt.left + 1*ridus;
			rc.right = rt.left + 3*ridus;
		}
		else
		{
			rc.left = rt.right - 3*ridus;
			rc.right = rt.right - 1*ridus;
		}
		
		rc.top = rt.top+rt.GetHeight()/2 - ridus;
		rc.bottom = rt.top+rt.GetHeight()/2 + ridus;
		
		DrawCircle(&rc);
	
	}

	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(0,0,255));
	SetStockFont(DEFAULT_GUI_FONT);
	DrawText(name,&rt,DT_VCENTER|DT_CENTER|DT_SINGLELINE);
	
	return OK;
}
int draw_2()
{

	CRect r,rt,rc;
	GetRect(&r);	
	int mode = (r.GetHeight()>0)?1:2;
	r.Normalize();
		
	rc.Copy(&r);
	align_rect(&rc,1);

	int border = 8;	
	rt.Copy(&rc);
	rt.left -= border;
	rt.right += border;
	rt.top -= border;
	rt.bottom += border;
	
	SetPen(PS_SOLID,2,RGB(0,0,0));
	DrawRect_2(&rt);
	
	int i,k=0,max;
	char buf[100];
	
	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(0,255,0));
	SetStockFont(DEFAULT_GUI_FONT);		

	int width_mode = 0;
	if(rc.right - rc.left >= 2*HOLE_WIDTH)
		width_mode = 1;
	int two_line=	rc.right - rc.left >= HOLE_WIDTH;
	
	max = rc.GetHeight() / HOLE_WIDTH +1;		
	for(i = rc.top; i <= rc.bottom; i+= HOLE_WIDTH)
	{
		draw_connect_dot(rc.left,i);
		if(mode == 1)
			sprintf(buf,"%d",k+1);
		else
		{
			if(two_line)sprintf(buf,"%d",max + k+1);
			else sprintf(buf,"%d",max -k);
		}
		k++;
			
		if(width_mode)
			TextOut(rc.left+3,i-4,buf);
		else
			TextOut(rc.left-15,i-4,buf);
	}
	
	k = 0;
	if(two_line)
	{
		for(i = rc.top; i <= rc.bottom; i+= HOLE_WIDTH)
		{
			draw_connect_dot(rc.right,i);
			if(mode == 1)
				sprintf(buf,"%d",2*max-k);
			else
				sprintf(buf,"%d",max - k);
			k++;
	
			if(width_mode)
				TextOut(rc.right-15,i-4,buf);
			else
				TextOut(rc.right+3,i-4,buf);
		}
		SetPen(PS_SOLID,2,RGB(0,0,0));		
		int ridus = 6;
		if(mode == 1)
		{
			rc.top = rt.top + 1*ridus;
			rc.bottom = rt.top + 3*ridus;
		}
		else
		{
			rc.top = rt.bottom - 3*ridus;
			rc.bottom = rt.bottom - 1*ridus;
		}
		
		rc.left = rt.left+rt.GetWidth()/2 - ridus;
		rc.right = rt.left+rt.GetWidth()/2 + ridus;
		
		DrawCircle(&rc);		
	}

	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(0,0,255));
	SetStockFont(DEFAULT_GUI_FONT);
	DrawText(name,&rt,DT_VCENTER|DT_CENTER|DT_SINGLELINE);

	return OK;
}
int draw()
{	
	CRect r;
	GetRect(&r);
	r.Normalize();
	
	if(r.GetWidth() >= r.GetHeight())
		draw_1();
	else
		draw_2();
	
	return OK;
}

]]>
</code>
<default>
<![CDATA[
name = "IC1"; //IC
]]>
</default>
</IC>
< isnode="true"  include="/WorkShop/PCB">
<code>
<![CDATA[
#include "pcb.h"
char *name;

int code(int code_num)
{
  return OK;
}
int before_draw()
{
	return OK;
}
int draw_1()
{
	CRect r,rt,rc;
	GetRect(&r);	
	int mode = (r.GetHeight()>0)?1:2;
	r.Normalize();
		
	int cx = r.left+ r.GetWidth() / 2;
	int cy = r.top + r.GetHeight() / 2;

	align(&cx);align(&cy);
	
	rc.left = cx - HOLE_WIDTH -6;
	rc.top   = cy - 6;
	rc.right = cx + HOLE_WIDTH+6;
	rc.bottom = cy + 6;
	SetPen(PS_SOLID,2,RGB(122,20,190));
	
	if(mode == 1)
	{
		DrawLine(rc.left,rc.top,rc.left,rc.bottom);
		DrawLine(rc.right,rc.top,rc.right,rc.bottom);
		DrawLine(rc.left,rc.bottom,rc.right,rc.bottom);
	
		rt.Copy(&rc);
		rt.top = rc.top - 10;
		rt.bottom = rc.top+10;
		
		int center_y = rt.top + rt.GetHeight()/2;
		Arc(rt.left,rt.top,rt.right,rt.bottom,
				rt.right,center_y,rt.left,center_y);	
	}		
	else
	{
		DrawLine(rc.left,rc.top,rc.left,rc.bottom);
		DrawLine(rc.right,rc.top,rc.right,rc.bottom);
		DrawLine(rc.left,rc.top,rc.right,rc.top);
		rt.Copy(&rc);
		rt.top = rc.bottom - 10;
		rt.bottom = rc.bottom+10;
		
		int center_y = rt.top + rt.GetHeight()/2;
		Arc(rt.left,rt.top,rt.right,rt.bottom,
				rt.left,center_y,rt.right,center_y);		
	}
	draw_connect_dot(cx,cy);
	draw_connect_dot(cx-HOLE_WIDTH,cy);
	draw_connect_dot(cx+HOLE_WIDTH,cy);
	
	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(122,20,190));
	SetStockFont(DEFAULT_GUI_FONT);		
	DrawText(name,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);
	
	return OK;
}
int draw_2()
{
	CRect r,rt,rc;
	GetRect(&r);	
	int mode = (r.GetWidth()>0)?1:2;
	r.Normalize();
		
	int cx = r.left+ r.GetWidth() / 2;
	int cy = r.top + r.GetHeight() / 2;

	align(&cx);align(&cy);
	
	rc.top = cy - HOLE_WIDTH -6;
	rc.left   = cx - 6;
	rc.bottom = cy + HOLE_WIDTH+6;
	rc.right = cx + 6;
	
	SetPen(PS_SOLID,2,RGB(122,20,190));
	
	if(mode == 1)
	{	
		DrawLine(rc.left,rc.top,rc.right,rc.top);
		DrawLine(rc.left,rc.bottom,rc.right,rc.bottom);
		DrawLine(rc.left,rc.top,rc.left,rc.bottom);
	
		rt.Copy(&rc);
		rt.left = rc.right - 10;
		rt.right = rc.right+10;
		
		int center_x = rt.left + rt.GetWidth()/2;
		Arc(rt.left,rt.top,rt.right,rt.bottom,
				center_x,rt.bottom,center_x,rt.top);	
	}		
	else
	{
		DrawLine(rc.left,rc.top,rc.right,rc.top);
		DrawLine(rc.left,rc.bottom,rc.right,rc.bottom);
		DrawLine(rc.right,rc.top,rc.right,rc.bottom);
	
		rt.Copy(&rc);
		rt.left = rc.left - 10;
		rt.right = rc.left+10;
		
		int center_x = rt.left + rt.GetWidth()/2;
		Arc(rt.left,rt.top,rt.right,rt.bottom,
				center_x,rt.top,center_x,rt.bottom);	
	}
	draw_connect_dot(cx,cy);
	draw_connect_dot(cx,cy-HOLE_WIDTH);
	draw_connect_dot(cx,cy+HOLE_WIDTH);
	
	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(122,20,190));
	SetStockFont(DEFAULT_GUI_FONT);		
	DrawText(name,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);


	return OK;
}
int draw()
{	
	CRect r;
	GetRect(&r);
	r.Normalize();
	
	if(r.GetWidth() >= r.GetHeight())
		draw_1();
	else
		draw_2();
	
	return OK;
}

]]>
</code>
<default>
<![CDATA[
name = "Q1"; //
]]>
</default>

</>
< isnode="true"  include="/WorkShop/PCB">
<code>
<![CDATA[
#include "pcb.h"
char *name;

int code(int code_num)
{
  return OK;
}
int before_draw()
{
	return OK;
}
int draw_1()
{
	CRect r,rt,rc;
	GetRect(&r);
	r.Normalize();
	
	int cx = r.left+ r.GetWidth() / 2;
	int cy = r.top + r.GetHeight() / 2;

	int x1,y1,x2,y2; //
	
	x1 = r.left;y1 = cy;
	align(&x1);align(&y1);
	
	x2 = r.right; y2 = cy;
	align(&x2);align(&y2);
	
	int crw = 32,crh = 12; //
	
	if(x2 - x1 > crw)
	{
		rc.left = x1 + (x2-x1) / 2 - crw / 2;
		rc.top =  y2 - crh / 2;
		rc.right = rc.left + crw;
		rc.bottom = rc.top + crh;
		
		SetPen(PS_SOLID,2,RGB(0,0,0));
		DrawLine(x1,y2,rc.left,y2);
		DrawLine(x2,y2,rc.right,y2);		
	}
	else
	{
		if(x2 - x1 < HOLE_WIDTH)
			x2 = x1 + HOLE_WIDTH;
			
		rc.left = x1;
		rc.top =  y2 - crh / 2;
		rc.right = x2;
		rc.bottom = rc.top + crh;
	}

	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(255,0,0));
	SetStockFont(DEFAULT_GUI_FONT);		
	DrawText(name,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);

	SetPen(PS_SOLID,2,RGB(0,0,255));
	
	
	int radix = rc.GetWidth() / 6;
	Arc(rc.left,rc.top,rc.left+2*radix,rc.top+2*radix,
			rc.left+2*radix,rc.top+radix,rc.left,rc.top+radix);
	
	Arc(rc.left+2*radix,rc.top,rc.left+4*radix,rc.top+2*radix,
			rc.left+4*radix,rc.top+radix,rc.left+2*radix,rc.top+radix);
	
	Arc(rc.left+4*radix,rc.top,rc.right,rc.top+2*radix,
			rc.right,rc.top+radix,rc.left+4*radix,rc.top+radix);
	
	draw_connect_dot(x1,y1);
	draw_connect_dot(x2,y2);
	
	return OK;
}
int draw_2()
{
	CRect r,rt,rc;
	GetRect(&r);
	r.Normalize();
	
	int cx = r.left+ r.GetWidth() / 2;
	int cy = r.top + r.GetHeight() / 2;

	int x1,y1,x2,y2; //
	
	x1 = cx;y1 = r.top;
	align(&x1);align(&y1);
	
	x2 = cx; y2 = r.bottom;
	align(&x2);align(&y2);
	
	int crh = 32,crw = 12; //
	
	if(y2 - y1 > crh)
	{
		rc.left = x1 - crw / 2;
		rc.top =  y1 - crh / 2 + (y2-y1)/2;
		rc.right = rc.left + crw;
		rc.bottom = rc.top + crh;
		
		SetPen(PS_SOLID,2,RGB(0,0,0));
		DrawLine(x1,y1,x1,rc.top);
		DrawLine(x2,y2,x2,rc.bottom);
	}
	else
	{
		if(y2 - y1 < HOLE_WIDTH)
			y2 = y1 + HOLE_WIDTH;			
		rc.left = x1 - crw / 2;
		rc.top =  y1;
		rc.right = rc.left + crw;
		rc.bottom = y2;
		//SetRect(&rc);
	}

	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(255,0,0));
	SetStockFont(DEFAULT_GUI_FONT);		
	DrawText(name,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);

	SetPen(PS_SOLID,2,RGB(0,0,255));
	
	int radix = rc.GetHeight() / 6;
	Arc(rc.left,rc.top,rc.left+2*radix,rc.top+2*radix,
			rc.left+radix,rc.top+2*radix,rc.left+radix,rc.top);
	
	Arc(rc.left,rc.top+2*radix,rc.left+2*radix,rc.top+4*radix,
			rc.left+radix,rc.top+4*radix,rc.left+radix,rc.top+2*radix);
	
	Arc(rc.left,rc.top+4*radix,rc.left+2*radix,rc.bottom,
			rc.left + radix,rc.bottom,rc.left+radix,rc.top+4*radix);
	
	draw_connect_dot(x1,y1);
	draw_connect_dot(x2,y2);

	
	draw_connect_dot(x1,y1);
	draw_connect_dot(x2,y2);
	
	return OK;
}
int draw()
{	
	CRect r;
	GetRect(&r);
	r.Normalize();
	
	if(r.GetWidth() >= r.GetHeight())
		draw_1();
	else
		draw_2();
	
	return OK;
}

]]>
</code>
<default>
<![CDATA[
name = "L1"; //
]]>
</default>

</>
< isnode="true"  include="/WorkShop/PCB">
<code>
<![CDATA[
#include "pcb.h"
char *text;

int code(int code_num)
{
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{
	CRect r;
	GetRect(&r);
	r.Normalize();
	
	SetPen(PS_SOLID,2,RGB(0,0,255));
	
	DrawRect_2(&r);
		
	SetPen(PS_SOLID,2,RGB(0,0,0));
	SetBkMode(TRANSPARENT);
	SetTextColor(RGB(255,0,0));
	SetStockFont(DEFAULT_GUI_FONT);

	DrawText(text,&r,DT_VCENTER|DT_CENTER|DT_SINGLELINE);
	return OK;
}

]]>
</code>
<default>
<![CDATA[
text = "Unknown"; 
]]>
</default>

</>
</>

<Others isnode="true" icon="33">
<other isnode="true">
<code>
<![CDATA[
CMem mem_code;
#define CODE mem_code.Printf
int code(int code_num)
{
	mem_code.Putc(0);
	if(code_num == 0)
	{
		puts(mem_code.p);
	}
  return OK;
}
int before_draw()
{
	return OK;
}
int draw()
{	
	return OK;
}

]]>
</code>
<default>
<![CDATA[
LOCAL_MEM(mem_code);
CRect r;
GetRect(&r);
r.Normalize();

SetPen(PS_SOLID,0,RGB(0,0,0));
DrawRect(&r);
CODE("%d,%d,%d,%d\n",r.left,r.top,r.right,r.bottom);

]]>
</default>

</other>
</Others>
</AllNode>
</WorkShop>
